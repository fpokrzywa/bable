{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/ai/flows/generate-widget-from-query.ts"],"sourcesContent":["// This file is machine-generated - edit at your own risk.\r\n\r\n'use server';\r\n\r\n/**\r\n * @fileOverview This file defines a Genkit flow that generates a widget based on a user query. It takes a query as input and returns a JSON object representing the widget data.\r\n *\r\n * @function generateWidgetFromQuery - The main function that takes a user query and returns widget data.\r\n * @interface GenerateWidgetFromQueryInput - The input type for the generateWidgetFromQuery function.\r\n * @interface GenerateWidgetFromQueryOutput - The output type for the generateWidgetFromQuery function.\r\n */\r\n\r\nimport {ai} from '@/ai/genkit';\r\nimport {z} from 'genkit';\r\nimport axios from 'axios';\r\n\r\nconst GenerateWidgetFromQueryInputSchema = z.object({\r\n  query: z.string().describe('The user query to generate the widget.'),\r\n  workspaceData: z.array(z.any()).optional().describe('Data from all open workspaces to provide context.'),\r\n});\r\nexport type GenerateWidgetFromQueryInput = z.infer<typeof GenerateWidgetFromQueryInputSchema>;\r\n\r\nconst GenerateWidgetFromQueryOutputSchema = z.object({\r\n  answer: z.string().describe('A natural language answer to the user query.'),\r\n  workspace_to_load: z.string().optional().describe('If the user wants to open a workspace, this is the name of the workspace to load.'),\r\n});\r\nexport type GenerateWidgetFromQueryOutput = z.infer<typeof GenerateWidgetFromQueryOutputSchema>;\r\n\r\nexport async function generateWidgetFromQuery(input: GenerateWidgetFromQueryInput): Promise<GenerateWidgetFromQueryOutput> {\r\n  return generateWidgetFromQueryFlow(input);\r\n}\r\n\r\nconst generateWidgetFromQueryFlow = ai.defineFlow(\r\n  {\r\n    name: 'generateWidgetFromQueryFlow',\r\n    inputSchema: GenerateWidgetFromQueryInputSchema,\r\n    outputSchema: GenerateWidgetFromQueryOutputSchema,\r\n  },\r\n  async (input) => {\r\n    const webhookUrl = process.env.APP_LLM_WEBHOOK_URL;\r\n    const llmConfig = process.env.APP_LLM_CONFIG;\r\n\r\n    if (!webhookUrl) {\r\n      throw new Error('APP_LLM_WEBHOOK_URL is not configured in the .env file.');\r\n    }\r\n\r\n    try {\r\n      const fullInput = {\r\n        query: input.query,\r\n        context: input.workspaceData,\r\n      };\r\n\r\n      const payload = {\r\n        input: fullInput,\r\n      };\r\n\r\n      // Use POST to send data in the body, avoiding URL length limits.\r\n      const response = await axios.post(webhookUrl, payload, {\r\n        params: {\r\n          llm: llmConfig?.toLowerCase(),\r\n        },\r\n      });\r\n\r\n      if (response.status === 200 && response.data) {\r\n        let responseData = response.data;\r\n        // Handle if response is an array\r\n        if (Array.isArray(responseData) && responseData.length > 0) {\r\n          responseData = responseData[0];\r\n        }\r\n\r\n        if (typeof responseData === 'object' && responseData !== null) {\r\n          return {\r\n            answer: responseData.answer || responseData.output || \"I received a response, but it was empty.\",\r\n            workspace_to_load: responseData.workspace_to_load\r\n          };\r\n        }\r\n        \r\n        // Handle plain string response for backward compatibility\r\n        return {\r\n          answer: responseData,\r\n        };\r\n      } else {\r\n        return { answer: `The webhook responded with status: ${response.status}` };\r\n      }\r\n    } catch (error) {\r\n      console.error('Error calling LLM webhook:', error);\r\n      let errorMessage = 'An error occurred while contacting the LLM webhook.';\r\n      if (axios.isAxiosError(error) && error.response) {\r\n        errorMessage = `Webhook error: ${error.response.status} - ${error.response.statusText}`;\r\n      } else if (axios.isAxiosError(error)) {\r\n        errorMessage = `Webhook request failed: ${error.message}`;\r\n      }\r\n      return { answer: errorMessage };\r\n    }\r\n  }\r\n);\r\n"],"names":[],"mappings":";;;;;;IA4BsB,0BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/ai/flows/agent-specific-widget.ts"],"sourcesContent":["'use server';\r\n\r\n/**\r\n * @fileOverview Dynamically assigns a ServiceNow agent to each widget based on its data.\r\n *\r\n * - agentSpecificWidget - A function that handles the agent assignment process.\r\n * - AgentSpecificWidgetInput - The input type for the agentSpecificWidget function.\r\n * - AgentSpecificWidgetOutput - The return type for the agentSpecificWidget function.\r\n */\r\n\r\nimport {ai} from '@/ai/genkit';\r\nimport {z} from 'genkit';\r\n\r\nconst AgentSpecificWidgetInputSchema = z.object({\r\n  widgetData: z.string().describe('The data associated with the widget.'),\r\n});\r\nexport type AgentSpecificWidgetInput = z.infer<typeof AgentSpecificWidgetInputSchema>;\r\n\r\nconst AgentSpecificWidgetOutputSchema = z.object({\r\n  agentType: z.string().describe('The type of ServiceNow agent assigned to the widget (e.g., incident agent, change agent).'),\r\n  agentBehavior: z.string().describe('The specific behavior of the agent within the widget.'),\r\n});\r\nexport type AgentSpecificWidgetOutput = z.infer<typeof AgentSpecificWidgetOutputSchema>;\r\n\r\nexport async function agentSpecificWidget(input: AgentSpecificWidgetInput): Promise<AgentSpecificWidgetOutput> {\r\n  return agentSpecificWidgetFlow(input);\r\n}\r\n\r\nconst prompt = ai.definePrompt({\r\n  name: 'agentSpecificWidgetPrompt',\r\n  input: {schema: AgentSpecificWidgetInputSchema},\r\n  output: {schema: AgentSpecificWidgetOutputSchema},\r\n  prompt: `Based on the following widget data, determine the most appropriate ServiceNow agent type and its corresponding behavior within the widget.\\n\\nWidget Data: {{{widgetData}}}\\n\\nConsider agent types like incident agent, change agent, problem agent, etc.\\nSpecify the agentType and a brief description of the agentBehavior applicable to this widget.`,\r\n});\r\n\r\nconst agentSpecificWidgetFlow = ai.defineFlow(\r\n  {\r\n    name: 'agentSpecificWidgetFlow',\r\n    inputSchema: AgentSpecificWidgetInputSchema,\r\n    outputSchema: AgentSpecificWidgetOutputSchema,\r\n  },\r\n  async input => {\r\n    const {output} = await prompt(input);\r\n    return output!;\r\n  }\r\n);\r\n"],"names":[],"mappings":";;;;;;IAwBsB,sBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/ai/flows/save-query-with-voice-text.ts"],"sourcesContent":["'use server';\r\n/**\r\n * @fileOverview A flow to save common queries or widget configurations using voice or text commands.\r\n *\r\n * - saveQueryWithVoiceText - A function that handles saving the query with voice or text.\r\n * - SaveQueryWithVoiceTextInput - The input type for the saveQueryWithVoiceText function.\r\n * - SaveQueryWithVoiceTextOutput - The return type for the saveQueryWithVoiceText function.\r\n */\r\n\r\nimport {ai} from '@/ai/genkit';\r\nimport {z} from 'genkit';\r\n\r\nconst SaveQueryWithVoiceTextInputSchema = z.object({\r\n  queryName: z.string().describe('The name of the query to be saved.'),\r\n  queryText: z.string().describe('The text of the query to be saved.'),\r\n});\r\nexport type SaveQueryWithVoiceTextInput = z.infer<typeof SaveQueryWithVoiceTextInputSchema>;\r\n\r\nconst SaveQueryWithVoiceTextOutputSchema = z.object({\r\n  success: z.boolean().describe('Whether the query was successfully saved.'),\r\n  message: z.string().describe('A message indicating the result of the save operation.'),\r\n});\r\nexport type SaveQueryWithVoiceTextOutput = z.infer<typeof SaveQueryWithVoiceTextOutputSchema>;\r\n\r\nexport async function saveQueryWithVoiceText(input: SaveQueryWithVoiceTextInput): Promise<SaveQueryWithVoiceTextOutput> {\r\n  return saveQueryWithVoiceTextFlow(input);\r\n}\r\n\r\nconst saveQueryWithVoiceTextPrompt = ai.definePrompt({\r\n  name: 'saveQueryWithVoiceTextPrompt',\r\n  input: {schema: SaveQueryWithVoiceTextInputSchema},\r\n  output: {schema: SaveQueryWithVoiceTextOutputSchema},\r\n  prompt: `You are a ServiceNow assistant helping users save their queries.\r\n  The user wants to save the following query with the given name.\r\n  If the query name is valid, save the query and return success as true.  Otherwise return false.\r\n\r\n  Query Name: {{{queryName}}}\r\n  Query Text: {{{queryText}}}\r\n  `,\r\n});\r\n\r\nconst saveQueryWithVoiceTextFlow = ai.defineFlow(\r\n  {\r\n    name: 'saveQueryWithVoiceTextFlow',\r\n    inputSchema: SaveQueryWithVoiceTextInputSchema,\r\n    outputSchema: SaveQueryWithVoiceTextOutputSchema,\r\n  },\r\n  async input => {\r\n    // TODO: Implement the logic to save the query.\r\n    // This is a placeholder implementation.\r\n    const {output} = await saveQueryWithVoiceTextPrompt(input);\r\n    return {\r\n      success: true,\r\n      message: `Query \"${input.queryName}\" saved successfully.`, \r\n    };\r\n  }\r\n);\r\n"],"names":[],"mappings":";;;;;;IAwBsB,yBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/ai/flows/generate-overview-summary.ts"],"sourcesContent":["'use server';\r\n/**\r\n * @fileOverview A flow to generate a summary from all open widgets.\r\n *\r\n * - generateOverviewSummary - A function that handles generating the summary.\r\n * - GenerateOverviewSummaryInput - The input type for the generateOverviewSummary function.\r\n * - GenerateOverviewSummaryOutput - The return type for the generateOverviewSummary function.\r\n */\r\n\r\nimport {ai} from '@/ai/genkit';\r\nimport {z} from 'genkit';\r\n\r\nconst GenerateOverviewSummaryInputSchema = z.object({\r\n  widgetData: z.array(z.any()).describe('The data from all open widgets.'),\r\n});\r\nexport type GenerateOverviewSummaryInput = z.infer<typeof GenerateOverviewSummaryInputSchema>;\r\n\r\nconst GenerateOverviewSummaryOutputSchema = z.object({\r\n  summary: z.string().describe('The generated summary of all widget data.'),\r\n});\r\nexport type GenerateOverviewSummaryOutput = z.infer<typeof GenerateOverviewSummaryOutputSchema>;\r\n\r\nexport async function generateOverviewSummary(input: GenerateOverviewSummaryInput): Promise<GenerateOverviewSummaryOutput> {\r\n  return generateOverviewSummaryFlow(input);\r\n}\r\n\r\nconst generateOverviewSummaryPrompt = ai.definePrompt({\r\n  name: 'generateOverviewSummaryPrompt',\r\n  input: {schema: GenerateOverviewSummaryInputSchema},\r\n  output: {schema: GenerateOverviewSummaryOutputSchema},\r\n  prompt: `You are a ServiceNow expert. Based on the data from all the open widgets below, provide a concise summary. The data is provided as a JSON object.\r\n\r\n  Widget Data:\r\n  {{{json widgetData}}}\r\n  `,\r\n});\r\n\r\nconst generateOverviewSummaryFlow = ai.defineFlow(\r\n  {\r\n    name: 'generateOverviewSummaryFlow',\r\n    inputSchema: GenerateOverviewSummaryInputSchema,\r\n    outputSchema: GenerateOverviewSummaryOutputSchema,\r\n  },\r\n  async input => {\r\n    const {output} = await generateOverviewSummaryPrompt(input);\r\n    return output!;\r\n  }\r\n);\r\n"],"names":[],"mappings":";;;;;;IAsBsB,0BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/ai/flows/context-aware-widget-chat.ts"],"sourcesContent":["// This file is machine-generated - edit with care!\r\n\r\n'use server';\r\n\r\n/**\r\n * @fileOverview Implements the context-aware chat functionality for widgets.\r\n *\r\n * - contextAwareWidgetChat - A function that suggests relevant data/actions based on the widget's context.\r\n * - ContextAwareWidgetChatInput - The input type for the contextAwareWidgetChat function.\r\n * - ContextAwareWidgetChatOutput - The return type for the contextAwareWidgetChat function.\r\n */\r\n\r\nimport {ai} from '@/ai/genkit';\r\nimport {z} from 'genkit';\r\n\r\nconst ChatHistorySchema = z.object({\r\n    role: z.enum(['user', 'model']),\r\n    content: z.string(),\r\n});\r\n\r\nconst ContextAwareWidgetChatInputSchema = z.object({\r\n  widgetType: z.string().describe('The type of widget (e.g., Incident, Change).'),\r\n  widgetData: z.any().describe('The data currently displayed in the widget.'),\r\n  userQuery: z.string().describe('The user input in the chat.'),\r\n  selectedEntityData: z.any().optional().describe('The data for the specific entity the user is asking about.'),\r\n  chatHistory: z.array(ChatHistorySchema).optional().describe('The previous chat history.'),\r\n  isGenericWidget: z.boolean().optional().describe('Flag to indicate if the widget is of generic type.'),\r\n});\r\nexport type ContextAwareWidgetChatInput = z.infer<typeof ContextAwareWidgetChatInputSchema>;\r\n\r\nconst ContextAwareWidgetChatOutputSchema = z.object({\r\n  suggestedActions: z.array(\r\n    z.string().describe('A list of suggested actions based on the widget context.')\r\n  ).\r\n  describe('The suggestions for the user to perform in the widget.')\r\n});\r\nexport type ContextAwareWidgetChatOutput = z.infer<typeof ContextAwareWidgetChatOutputSchema>;\r\n\r\nexport async function contextAwareWidgetChat(input: ContextAwareWidgetChatInput): Promise<ContextAwareWidgetChatOutput> {\r\n  return contextAwareWidgetChatFlow(input);\r\n}\r\n\r\nconst contextAwareWidgetChatPrompt = ai.definePrompt({\r\n  name: 'contextAwareWidgetChatPrompt',\r\n  input: {schema: ContextAwareWidgetChatInputSchema},\r\n  output: {schema: ContextAwareWidgetChatOutputSchema},\r\n  prompt: `You are an AI assistant within a ServiceNow widget.\r\n\r\n  Based on the widget type and its current data, suggest relevant actions or answer questions.\r\n  Consider the user's last query and the chat history to refine your suggestions.\r\n\r\n  Widget Type: {{{widgetType}}}\r\n  {{#if selectedEntityData}}\r\n  The user is specifically asking about the following record (identified by number and sys_id):\r\n  {{{json selectedEntityData}}}\r\n  {{else}}\r\n  Widget Data:\r\n  {{#if isGenericWidget}}\r\n  {{{widgetData}}}\r\n  {{else}}\r\n  {{{json widgetData}}}\r\n  {{/if}}\r\n  {{/if}}\r\n\r\n  {{#if chatHistory}}\r\n  Conversation History:\r\n  {{#each chatHistory}}\r\n  - {{this.role}}: {{this.content}}\r\n  {{/each}}\r\n  {{/if}}\r\n\r\n  User's Latest Query: {{{userQuery}}}\r\n\r\n  If the user asks a question, answer it based on the provided data and chat history. If they ask for an action, suggest relevant actions (e.g., \"search for related knowledge articles\", \"update incident priority\", \"assign to correct group\").\r\n\r\n  Return a JSON array of strings with the suggested actions or answer.\r\n\r\n  Example Output for suggestions:\r\n  {\r\n    \"suggestedActions\": [\r\n      \"Search for related knowledge articles\",\r\n      \"Update incident priority\",\r\n      \"Add a comment to the incident\"\r\n    ]\r\n  }\r\n\r\n\r\n  Example Output for an answer:\r\n  {\r\n    \"suggestedActions\": [\r\n      \"The priority of this incident is 1 - Critical.\"\r\n    ]\r\n  }\r\n  `,\r\n});\r\n\r\nconst contextAwareWidgetChatFlow = ai.defineFlow(\r\n  {\r\n    name: 'contextAwareWidgetChatFlow',\r\n    inputSchema: ContextAwareWidgetChatInputSchema,\r\n    outputSchema: ContextAwareWidgetChatOutputSchema,\r\n  },\r\n  async (input) => {\r\n    const promptInput = {\r\n      ...input,\r\n      isGenericWidget: input.widgetType === 'generic',\r\n    };\r\n    const {output} = await contextAwareWidgetChatPrompt(promptInput);\r\n    return output!;\r\n  }\r\n);\r\n"],"names":[],"mappings":";;;;;;IAsCsB,yBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/hooks/use-mobile.tsx"],"sourcesContent":["import * as React from \"react\"\r\n\r\nconst MOBILE_BREAKPOINT = 768\r\n\r\nexport function useIsMobile() {\r\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\r\n\r\n  React.useEffect(() => {\r\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\r\n    const onChange = () => {\r\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\r\n    }\r\n    mql.addEventListener(\"change\", onChange)\r\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\r\n    return () => mql.removeEventListener(\"change\", onChange)\r\n  }, [])\r\n\r\n  return !!isMobile\r\n}\r\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,oBAAoB;AAEnB,SAAS;IACd,MAAM,CAAC,UAAU,YAAY,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAc,AAAD,EAAuB;IAEpE,CAAA,GAAA,qMAAA,CAAA,YAAe,AAAD,EAAE;QACd,MAAM,MAAM,OAAO,UAAU,CAAC,CAAC,YAAY,EAAE,oBAAoB,EAAE,GAAG,CAAC;QACvE,MAAM,WAAW;YACf,YAAY,OAAO,UAAU,GAAG;QAClC;QACA,IAAI,gBAAgB,CAAC,UAAU;QAC/B,YAAY,OAAO,UAAU,GAAG;QAChC,OAAO,IAAM,IAAI,mBAAmB,CAAC,UAAU;IACjD,GAAG,EAAE;IAEL,OAAO,CAAC,CAAC;AACX","debugId":null}},
    {"offset": {"line": 97, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/hooks/use-find-answers-sync.ts"],"sourcesContent":["'use client';\r\n\r\nimport { useEffect, useRef, useState } from 'react';\r\nimport { getFindAnswersItems, type FindAnswersItem } from '@/services/findAnswersService';\r\nimport type { User } from '@/lib/types';\r\nimport { useToast } from '@/hooks/use-toast';\r\n\r\ninterface UseFindAnswersSyncOptions {\r\n    user: User | null;\r\n    findAnswersItems: FindAnswersItem[];\r\n    onFindAnswersChanged: (items: FindAnswersItem[]) => void;\r\n    enabled?: boolean;\r\n    intervalMs?: number;\r\n    showNotifications?: boolean;\r\n}\r\n\r\nexport function useFindAnswersSync({\r\n    user,\r\n    findAnswersItems,\r\n    onFindAnswersChanged,\r\n    enabled = true,\r\n    intervalMs = 60000, // Default: 60 seconds (longer than workspaces since this data changes less frequently)\r\n    showNotifications = true\r\n}: UseFindAnswersSyncOptions) {\r\n    const { toast } = useToast();\r\n    const [isChecking, setIsChecking] = useState(false);\r\n    const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);\r\n    const intervalRef = useRef<NodeJS.Timeout>();\r\n    const isActiveRef = useRef(true);\r\n\r\n    // Pause sync when tab is not visible\r\n    useEffect(() => {\r\n        const handleVisibilityChange = () => {\r\n            isActiveRef.current = !document.hidden;\r\n        };\r\n\r\n        document.addEventListener('visibilitychange', handleVisibilityChange);\r\n        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n    }, []);\r\n\r\n    // Function to detect changes between old and new items\r\n    const detectChanges = (oldItems: FindAnswersItem[], newItems: FindAnswersItem[]) => {\r\n        const oldMap = new Map(oldItems.map(item => [item.id, item]));\r\n        const newMap = new Map(newItems.map(item => [item.id, item]));\r\n\r\n        const added = newItems.filter(item => !oldMap.has(item.id));\r\n        const deleted = oldItems.filter(item => !newMap.has(item.id));\r\n        const modified = newItems.filter(item => {\r\n            const oldItem = oldMap.get(item.id);\r\n            return oldItem && (\r\n                oldItem.title !== item.title ||\r\n                oldItem.icon !== item.icon ||\r\n                oldItem.type !== item.type ||\r\n                oldItem.url !== item.url\r\n            );\r\n        });\r\n\r\n        return {\r\n            hasChanges: added.length > 0 || deleted.length > 0 || modified.length > 0,\r\n            added,\r\n            deleted,\r\n            modified\r\n        };\r\n    };\r\n\r\n    const checkForChanges = async (silent = false) => {\r\n        if (!enabled || isChecking || !isActiveRef.current) return;\r\n\r\n        setIsChecking(true);\r\n        try {\r\n            const newItems = await getFindAnswersItems();\r\n            const changes = detectChanges(findAnswersItems, newItems);\r\n            \r\n            if (changes.hasChanges) {\r\n                console.log('Find Answers changes detected:', changes);\r\n                \r\n                // Update with new items\r\n                onFindAnswersChanged(newItems);\r\n                \r\n                // Show notifications if enabled and not silent\r\n                if (showNotifications && !silent) {\r\n                    const messages = [];\r\n                    if (changes.added.length > 0) {\r\n                        messages.push(`${changes.added.length} new item(s) added`);\r\n                    }\r\n                    if (changes.modified.length > 0) {\r\n                        messages.push(`${changes.modified.length} item(s) updated`);\r\n                    }\r\n                    if (changes.deleted.length > 0) {\r\n                        messages.push(`${changes.deleted.length} item(s) removed`);\r\n                    }\r\n                    \r\n                    toast({\r\n                        title: 'Find Answers Updated',\r\n                        description: messages.join(', '),\r\n                        duration: 3000,\r\n                    });\r\n                }\r\n            }\r\n            \r\n            setLastSyncTime(new Date());\r\n        } catch (error) {\r\n            console.error('Failed to sync Find Answers:', error);\r\n        } finally {\r\n            setIsChecking(false);\r\n        }\r\n    };\r\n\r\n    // Manual sync function\r\n    const syncNow = () => {\r\n        checkForChanges(false);\r\n    };\r\n\r\n    // Set up periodic sync\r\n    useEffect(() => {\r\n        if (!enabled) {\r\n            if (intervalRef.current) {\r\n                clearInterval(intervalRef.current);\r\n                intervalRef.current = undefined;\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Initial check after a short delay\r\n        const initialTimeout = setTimeout(() => {\r\n            checkForChanges(true); // Silent initial check\r\n        }, 5000); // Slightly longer initial delay\r\n\r\n        // Set up periodic checks\r\n        intervalRef.current = setInterval(() => {\r\n            checkForChanges(true); // Silent periodic checks\r\n        }, intervalMs);\r\n\r\n        return () => {\r\n            clearTimeout(initialTimeout);\r\n            if (intervalRef.current) {\r\n                clearInterval(intervalRef.current);\r\n            }\r\n        };\r\n    }, [enabled, intervalMs, findAnswersItems.length]); // Include findAnswersItems.length to restart when items change\r\n\r\n    // Cleanup on unmount\r\n    useEffect(() => {\r\n        return () => {\r\n            if (intervalRef.current) {\r\n                clearInterval(intervalRef.current);\r\n            }\r\n        };\r\n    }, []);\r\n\r\n    return {\r\n        isChecking,\r\n        lastSyncTime,\r\n        syncNow,\r\n        enabled: enabled\r\n    };\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 233, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/hooks/use-workspace-sync.ts"],"sourcesContent":["'use client';\r\n\r\nimport { useEffect, useRef, useState } from 'react';\r\nimport { detectWorkspaceChanges, type WorkspaceChanges } from '@/services/workspaceService';\r\nimport { updateCachedWorkspaces } from '@/services/userService';\r\nimport type { Workspace, User } from '@/lib/types';\r\nimport { useToast } from '@/hooks/use-toast';\r\n\r\ninterface UseWorkspaceSyncOptions {\r\n    user: User | null;\r\n    workspaces: Workspace[];\r\n    onWorkspacesChanged: (workspaces: Workspace[]) => void;\r\n    onWorkspacesDeleted: (deletedIds: string[]) => void;\r\n    enabled?: boolean;\r\n    intervalMs?: number;\r\n    showNotifications?: boolean;\r\n}\r\n\r\nexport function useWorkspaceSync({\r\n    user,\r\n    workspaces,\r\n    onWorkspacesChanged,\r\n    onWorkspacesDeleted,\r\n    enabled = true,\r\n    intervalMs = 30000, // Default: 30 seconds\r\n    showNotifications = true\r\n}: UseWorkspaceSyncOptions) {\r\n    const { toast } = useToast();\r\n    const [isChecking, setIsChecking] = useState(false);\r\n    const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);\r\n    const intervalRef = useRef<NodeJS.Timeout>();\r\n    const isActiveRef = useRef(true);\r\n\r\n    // Pause sync when tab is not visible\r\n    useEffect(() => {\r\n        const handleVisibilityChange = () => {\r\n            isActiveRef.current = !document.hidden;\r\n        };\r\n\r\n        document.addEventListener('visibilitychange', handleVisibilityChange);\r\n        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n    }, []);\r\n\r\n    const checkForChanges = async (silent = false) => {\r\n        if (!user || !enabled || isChecking || !isActiveRef.current) return;\r\n\r\n        setIsChecking(true);\r\n        try {\r\n            const changes = await detectWorkspaceChanges(user.userId, workspaces);\r\n            \r\n            if (changes.hasChanges) {\r\n                console.log('Workspace changes detected:', changes);\r\n                \r\n                // Apply changes to workspaces\r\n                let updatedWorkspaces = [...workspaces];\r\n                \r\n                // Remove deleted workspaces\r\n                if (changes.deleted.length > 0) {\r\n                    updatedWorkspaces = updatedWorkspaces.filter(\r\n                        ws => !changes.deleted.includes(ws.workspaceId)\r\n                    );\r\n                    onWorkspacesDeleted(changes.deleted);\r\n                }\r\n                \r\n                // Add new workspaces\r\n                if (changes.added.length > 0) {\r\n                    updatedWorkspaces = [...updatedWorkspaces, ...changes.added];\r\n                }\r\n                \r\n                // Update modified workspaces\r\n                if (changes.modified.length > 0) {\r\n                    const modifiedMap = new Map(changes.modified.map(ws => [ws.workspaceId, ws]));\r\n                    updatedWorkspaces = updatedWorkspaces.map(ws => \r\n                        modifiedMap.get(ws.workspaceId) || ws\r\n                    );\r\n                }\r\n                \r\n                // Update cache and state\r\n                updateCachedWorkspaces(updatedWorkspaces);\r\n                onWorkspacesChanged(updatedWorkspaces);\r\n                \r\n                // Show notifications if enabled and not silent\r\n                if (showNotifications && !silent) {\r\n                    const messages = [];\r\n                    if (changes.added.length > 0) {\r\n                        messages.push(`${changes.added.length} workspace(s) added`);\r\n                    }\r\n                    if (changes.modified.length > 0) {\r\n                        messages.push(`${changes.modified.length} workspace(s) updated`);\r\n                    }\r\n                    if (changes.deleted.length > 0) {\r\n                        messages.push(`${changes.deleted.length} workspace(s) removed`);\r\n                    }\r\n                    \r\n                    toast({\r\n                        title: 'Workspaces Updated',\r\n                        description: messages.join(', '),\r\n                        duration: 3000,\r\n                    });\r\n                }\r\n            }\r\n            \r\n            setLastSyncTime(new Date());\r\n        } catch (error) {\r\n            console.error('Failed to sync workspaces:', error);\r\n        } finally {\r\n            setIsChecking(false);\r\n        }\r\n    };\r\n\r\n    // Manual sync function\r\n    const syncNow = () => {\r\n        checkForChanges(false);\r\n    };\r\n\r\n    // Set up periodic sync\r\n    useEffect(() => {\r\n        if (!enabled || !user) {\r\n            if (intervalRef.current) {\r\n                clearInterval(intervalRef.current);\r\n                intervalRef.current = undefined;\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Initial check after a short delay\r\n        const initialTimeout = setTimeout(() => {\r\n            checkForChanges(true); // Silent initial check\r\n        }, 2000);\r\n\r\n        // Set up periodic checks\r\n        intervalRef.current = setInterval(() => {\r\n            checkForChanges(true); // Silent periodic checks\r\n        }, intervalMs);\r\n\r\n        return () => {\r\n            clearTimeout(initialTimeout);\r\n            if (intervalRef.current) {\r\n                clearInterval(intervalRef.current);\r\n            }\r\n        };\r\n    }, [user, enabled, intervalMs, workspaces.length]); // Include workspaces.length to restart when workspaces change\r\n\r\n    // Cleanup on unmount\r\n    useEffect(() => {\r\n        return () => {\r\n            if (intervalRef.current) {\r\n                clearInterval(intervalRef.current);\r\n            }\r\n        };\r\n    }, []);\r\n\r\n    return {\r\n        isChecking,\r\n        lastSyncTime,\r\n        syncNow,\r\n        enabled: enabled && !!user\r\n    };\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 373, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/findAnswersService.ts"],"sourcesContent":["import axios from 'axios';\r\n\r\nexport interface FindAnswersItem {\r\n    id: string;\r\n    title: string;\r\n    icon?: string;\r\n    type?: string;\r\n    url?: string;\r\n}\r\n\r\nconst getFindAnswersWebhookUrl = () => {\r\n    const url = process.env.NEXT_PUBLIC_FIND_ANSWERS_WEBHOOK_URL;\r\n    if (!url) {\r\n        console.warn('NEXT_PUBLIC_FIND_ANSWERS_WEBHOOK_URL is not configured in .env file.');\r\n        return null;\r\n    }\r\n    return url;\r\n};\r\n\r\nexport async function getFindAnswersDetailById(id: string): Promise<any> {\r\n    // TODO: Replace with actual API call to fetch detailed data by ID\r\n    // For now, return mock data based on the provided example\r\n    const mockData = {\r\n        _id: { $oid: \"6887752a9cc59c08e7f38b58\" },\r\n        id: \"A1970-2\",\r\n        title: \"IT Support Guides\",\r\n        description: \"Quick solutions and how-to guides for common IT issues within the company.\",\r\n        learnMoreLink: \"Explore all IT Support Resources\",\r\n        scenario: \"Explore IT Support Guides to find helpful information and resources.\",\r\n        actions: [\r\n            \"Ask ODIN questions about IT support guides\",\r\n            \"Get instant answers and guidance\", \r\n            \"Find relevant policies and procedures\"\r\n        ],\r\n        articles: [\r\n            {\r\n                id: \"article-1\",\r\n                policyName: \"Password Reset Procedures\",\r\n                content: \"Step-by-step guide for resetting passwords across company systems. This includes self-service options, security verification steps, and escalation procedures when automated reset fails.\",\r\n                category: \"Security\",\r\n                url: \"https://company.com/kb/password-reset\",\r\n                lastUpdated: \"2024-01-15T10:30:00Z\",\r\n                author: \"IT Security Team\"\r\n            },\r\n            {\r\n                id: \"article-2\",\r\n                policyName: \"Software Installation Guide\",\r\n                content: \"Instructions for installing approved software and requesting new applications. Covers standard software packages, approval workflows, and security requirements.\",\r\n                category: \"Software\",\r\n                url: \"https://company.com/kb/software-install\",\r\n                lastUpdated: \"2024-01-10T14:20:00Z\",\r\n                author: \"IT Operations\"\r\n            },\r\n            {\r\n                id: \"article-3\",\r\n                policyName: \"Network Troubleshooting\",\r\n                content: \"Common network issues and solutions for connectivity problems. Includes WiFi troubleshooting, VPN setup, and network diagnostics.\",\r\n                category: \"Network\",\r\n                url: \"https://company.com/kb/network\",\r\n                lastUpdated: \"2024-01-08T09:15:00Z\",\r\n                author: \"Network Team\"\r\n            }\r\n        ]\r\n    };\r\n\r\n    // Customize the data based on the ID\r\n    switch (id) {\r\n        case 'my-support-guides':\r\n            return {\r\n                ...mockData,\r\n                id: \"A1970-3\",\r\n                title: \"My Support Guides\",\r\n                description: \"Quick solutions and how-to guides for common IT issues within the company.\",\r\n                scenario: \"Explore IT Support Guides to find helpful information and resources.\",\r\n                actions: [\r\n                    \"Ask ODIN questions about IT support guides\",\r\n                    \"Get instant answers and guidance\", \r\n                    \"Find relevant policies and procedures\"\r\n                ]\r\n            };\r\n        case 'hr-policies':\r\n            return {\r\n                ...mockData,\r\n                id: \"A1970-4\",\r\n                title: \"HR Policies\",\r\n                description: \"Human resources policies and procedures for employees.\",\r\n                articles: [\r\n                    {\r\n                        id: \"hr-article-1\",\r\n                        policyName: \"Employee Handbook\",\r\n                        content: \"Comprehensive guide covering company policies, procedures, and expectations for all employees.\",\r\n                        category: \"Policy\",\r\n                        lastUpdated: \"2024-01-20T11:00:00Z\",\r\n                        author: \"HR Department\"\r\n                    },\r\n                    {\r\n                        id: \"hr-article-2\",\r\n                        policyName: \"Leave Management\",\r\n                        content: \"Guidelines for requesting and managing various types of leave including vacation, sick leave, and personal time off.\",\r\n                        category: \"Benefits\",\r\n                        lastUpdated: \"2024-01-18T14:30:00Z\",\r\n                        author: \"HR Benefits Team\"\r\n                    }\r\n                ]\r\n            };\r\n        case 'niea-guides':\r\n            return {\r\n                ...mockData,\r\n                id: \"A1970-5\",\r\n                title: \"NIEA Guides\",\r\n                description: \"NIEA-specific guides and documentation for compliance and procedures.\"\r\n            };\r\n        case 'adept-guides':\r\n            return {\r\n                ...mockData,\r\n                id: \"A1970-6\",\r\n                title: \"ADEPT Guides\",\r\n                description: \"ADEPT system guides and resources for advanced users.\"\r\n            };\r\n        default:\r\n            return mockData;\r\n    }\r\n}\r\n\r\nexport async function getFindAnswersItems(): Promise<FindAnswersItem[]> {\r\n    const webhookUrl = getFindAnswersWebhookUrl();\r\n    if (!webhookUrl) {\r\n        // Return default items if webhook is not configured\r\n        return [\r\n            { id: 'it-support-guides', title: 'IT Support Guides', icon: 'headphones' },\r\n            { id: 'my-support-guides', title: 'My Support Guides', icon: 'headphones' },\r\n            { id: 'hr-policies', title: 'HR Policies', icon: 'users' },\r\n            { id: 'niea-guides', title: 'NIEA Guides', icon: 'file-text' },\r\n            { id: 'adept-guides', title: 'ADEPT Guides', icon: 'book-open' },\r\n        ];\r\n    }\r\n\r\n    try {\r\n        const response = await axios.get(webhookUrl);\r\n        \r\n        if (response.status === 200 && response.data) {\r\n            // Handle both array and object responses\r\n            const data = Array.isArray(response.data) ? response.data : \r\n                        response.data.items || response.data.data || response.data.answers || [];\r\n            \r\n            if (Array.isArray(data)) {\r\n                return data.map((item: any, index: number) => ({\r\n                    id: item.id || item.key || `find-answer-${index}`,\r\n                    title: item.title || item.name || item.label || 'Untitled',\r\n                    icon: item.icon || 'help-circle',\r\n                    type: item.type || 'guide',\r\n                    url: item.url || item.link\r\n                }));\r\n            }\r\n        }\r\n\r\n        console.warn('Find Answers webhook returned invalid data format');\r\n        return [];\r\n    } catch (error) {\r\n        console.error('Failed to fetch Find Answers items:', error);\r\n        // Return empty array on error - the section will show no items\r\n        return [];\r\n    }\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 552, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/workspaceService.ts"],"sourcesContent":["\r\n\r\n'use server';\r\n\r\nimport axios from 'axios';\r\nimport type { Workspace } from '@/lib/types';\r\n\r\nconst getWorkspaceWebhookUrl = () => {\r\n    const url = process.env.WORKSPACE_WEBHOOK_URL;\r\n    if (!url) {\r\n        throw new Error('WORKSPACE_WEBHOOK_URL is not configured in .env file.');\r\n    }\r\n    return url;\r\n};\r\n\r\nconst getUserWorkspacesWebhookUrl = () => {\r\n    const url = process.env.USER_WORKSPACE_WEBHOOK_URL;\r\n    if (!url) {\r\n        console.warn('USER_WORKSPACE_WEBHOOK_URL is not configured in .env file - workspace sync disabled');\r\n        return null;\r\n    }\r\n    return url;\r\n};\r\n\r\nexport async function getWorkspaces(userId: string): Promise<Workspace[]> {\r\n    try {\r\n        const webhookUrl = getUserWorkspacesWebhookUrl();\r\n        if (!webhookUrl) {\r\n            return []; // Gracefully return empty array if webhook URL is not configured\r\n        }\r\n        const response = await axios.get(webhookUrl, { params: { userId, workspaceId: 'all' } });\r\n        if (response.status === 200 && response.data) {\r\n            return Array.isArray(response.data) ? response.data : [response.data];\r\n        }\r\n        return [];\r\n    } catch (error: any) {\r\n        // Only log detailed errors for non-404 status codes\r\n        if (error?.response?.status !== 404) {\r\n            console.error('Failed to get workspaces:', error);\r\n        } else {\r\n            console.warn('Workspace endpoint not found (404) - using local workspace management');\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport interface WorkspaceChanges {\r\n    added: Workspace[];\r\n    deleted: string[];\r\n    modified: Workspace[];\r\n    hasChanges: boolean;\r\n}\r\n\r\nexport async function detectWorkspaceChanges(userId: string, currentWorkspaces: Workspace[]): Promise<WorkspaceChanges> {\r\n    try {\r\n        const freshWorkspaces = await getWorkspaces(userId);\r\n        \r\n        const currentMap = new Map(currentWorkspaces.map(ws => [ws.workspaceId, ws]));\r\n        const freshMap = new Map(freshWorkspaces.map(ws => [ws.workspaceId, ws]));\r\n        \r\n        const added: Workspace[] = [];\r\n        const modified: Workspace[] = [];\r\n        const deleted: string[] = [];\r\n        \r\n        // Find added and modified workspaces\r\n        for (const [id, freshWs] of freshMap) {\r\n            const currentWs = currentMap.get(id);\r\n            if (!currentWs) {\r\n                added.push(freshWs);\r\n            } else if (JSON.stringify(currentWs) !== JSON.stringify(freshWs)) {\r\n                modified.push(freshWs);\r\n            }\r\n        }\r\n        \r\n        // Find deleted workspaces\r\n        for (const [id] of currentMap) {\r\n            if (!freshMap.has(id)) {\r\n                deleted.push(id);\r\n            }\r\n        }\r\n        \r\n        return {\r\n            added,\r\n            deleted,\r\n            modified,\r\n            hasChanges: added.length > 0 || deleted.length > 0 || modified.length > 0\r\n        };\r\n    } catch (error) {\r\n        console.error('Failed to detect workspace changes:', error);\r\n        return {\r\n            added: [],\r\n            deleted: [],\r\n            modified: [],\r\n            hasChanges: false\r\n        };\r\n    }\r\n}\r\n\r\n\r\nexport async function saveWorkspace(workspaceData: Omit<Workspace, 'workspaceId' | 'active'> & { workspaceId?: string }): Promise<Workspace | null> {\r\n    const webhookUrl = getWorkspaceWebhookUrl();\r\n    const workspaceId = workspaceData.workspaceId || `ws_${Date.now()}`;\r\n    const payload = {\r\n        ...workspaceData,\r\n        workspaceId: workspaceId,\r\n        active: true,\r\n    };\r\n\r\n\r\n    try {\r\n        const response = await axios.post(webhookUrl, payload, { params: { workspaceId } });\r\n        if (response.status === 200 || response.status === 201) {\r\n            // The webhook can return the saved object directly or inside a 'result' property\r\n            return response.data?.result || response.data;\r\n        }\r\n        return null;\r\n    } catch (error: any) {\r\n        if (axios.isAxiosError(error)) {\r\n            // Only log detailed errors for non-404 status codes\r\n            if (error?.response?.status !== 404) {\r\n                console.error('Failed to save workspace:', {\r\n                    message: error.message,\r\n                    status: error.response?.status,\r\n                    data: error.response?.data,\r\n                    url: webhookUrl,\r\n                    sentData: payload\r\n                });\r\n            } else {\r\n                console.warn('Workspace save endpoint not found (404) - workspace not saved to remote');\r\n            }\r\n        } else {\r\n            console.error('An unexpected error occurred during workspace save:', error);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function deleteWorkspace(workspaceId: string): Promise<boolean> {\r\n    const webhookUrl = getWorkspaceWebhookUrl();\r\n    try {\r\n        const response = await axios.delete(webhookUrl, { params: { workspaceId } });\r\n        return response.status === 200 || response.status === 204;\r\n    } catch (error: any) {\r\n        // Only log detailed errors for non-404 status codes\r\n        if (error?.response?.status !== 404) {\r\n            console.error('Failed to delete workspace:', error);\r\n        } else {\r\n            console.warn('Workspace delete endpoint not found (404) - workspace not deleted from remote');\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;IAwBsB,gBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 565, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/userService.ts"],"sourcesContent":["// This file contains both server and client functions\r\n\r\nimport axios from 'axios';\r\nimport type { User, Workspace } from '@/lib/types';\r\nimport { getWorkspaces } from './workspaceService';\r\n\r\nconst getUserApiUrl = () => {\r\n    const url = process.env.NEXT_PUBLIC_GET_USERS_URL;\r\n    if (!url) {\r\n        console.warn('NEXT_PUBLIC_GET_USERS_URL is not configured. User management may not work correctly.');\r\n        return null;\r\n    }\r\n    return url;\r\n};\r\n\r\nconst getUpdateWebhookUrl = () => {\r\n    const url = process.env.NEXT_PUBLIC_USER_PROFILE_UPDATE_WEBHOOK_URL;\r\n    if (!url) {\r\n        console.warn('NEXT_PUBLIC_USER_PROFILE_UPDATE_WEBHOOK_URL is not configured in .env file.');\r\n        return null;\r\n    }\r\n    return url;\r\n}\r\n\r\nconst getProfileWebhookUrl = () => {\r\n    const url = process.env.NEXT_PUBLIC_USER_PROFILE_WEBHOOK_URL;\r\n    if (!url) {\r\n        console.warn('NEXT_PUBLIC_USER_PROFILE_WEBHOOK_URL is not configured in .env file. Using fallback data.');\r\n        return null;\r\n    }\r\n    return url;\r\n};\r\n\r\n\r\nconst createDefaultUser = (email: string): User => ({\r\n    userId: email,\r\n    username: 'Default User',\r\n    first_name: 'Default',\r\n    last_name: 'User',\r\n    email: email,\r\n    bio: 'Please configure your user profile webhook in the .env file to fetch real user data.',\r\n    avatar: `https://i.pravatar.cc/150?u=${email}`,\r\n    roles: ['User'],\r\n});\r\n\r\nexport async function getUserById(userId: string): Promise<User | null> {\r\n    const webhookUrl = getUserApiUrl();\r\n    if (!webhookUrl) {\r\n        console.warn('NEXT_PUBLIC_GET_USERS_URL is not configured. Falling back to default user.');\r\n        return createDefaultUser(userId);\r\n    }\r\n\r\n    try {\r\n        const response = await axios.get(webhookUrl, { params: { userId } });\r\n        \r\n        if (response.status === 200 && response.data) {\r\n            // Handle both direct user object and wrapped responses\r\n            const userData = Array.isArray(response.data) ? response.data[0] : response.data;\r\n            if (userData) {\r\n                return {\r\n                    ...userData,\r\n                    userId: userData.userId || userData._id,\r\n                    roles: userData.roles || ['User']\r\n                };\r\n            }\r\n        }\r\n        \r\n        console.warn(`No user found for userId: ${userId}`);\r\n        return null;\r\n    } catch (error) {\r\n        if (axios.isAxiosError(error)) {\r\n            if (error.response?.status === 404) {\r\n                console.warn(`User not found (userId: ${userId})`);\r\n                return null;\r\n            } else {\r\n                console.error(`Failed to fetch user by ID ${userId}:`, error.message);\r\n            }\r\n        } else {\r\n            console.error('An unexpected error occurred:', error);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function getAllUsers(): Promise<User[]> {\r\n    const webhookUrl = getUserApiUrl();\r\n    if (!webhookUrl) {\r\n        return [\r\n            {...createDefaultUser('user1@example.com'), roles: ['Admin']},\r\n            createDefaultUser('user2@example.com'),\r\n        ];\r\n    }\r\n    try {\r\n        const response = await axios.get(webhookUrl, { params: { userId: 'all' } });\r\n\r\n        if (response.status === 200 && Array.isArray(response.data)) {\r\n            return response.data.map(user => ({\r\n                ...user,\r\n                userId: user.userId || user._id, // Handle both possible ID fields\r\n                roles: user.roles || ['User']\r\n            }));\r\n        }\r\n        \r\n        // Handle cases where the API returns an object with a 'data' or other property\r\n        if (response.status === 200 && response.data && typeof response.data === 'object') {\r\n            const userArray = response.data.data || response.data.users || response.data.items || response.data.result;\r\n            if (Array.isArray(userArray)) {\r\n                return userArray.map(user => ({\r\n                    ...user,\r\n                    userId: user.userId || user._id,\r\n                    roles: user.roles || ['User']\r\n                }));\r\n            }\r\n        }\r\n        \r\n        console.warn(\"Webhook response for all users was not in a recognized array format. Returning empty array.\", response.data);\r\n        return [];\r\n    } catch (error) {\r\n        console.error('Failed to get all users from webhook:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n\r\nexport async function getUserProfile(email: string): Promise<User | null> {\r\n    const webhookUrl = getProfileWebhookUrl();\r\n\r\n    if (!webhookUrl) {\r\n        return createDefaultUser(email);\r\n    }\r\n\r\n    try {\r\n        const response = await axios.get(webhookUrl, { params: { userId: email } });\r\n        \r\n        if (response.status === 200 && response.data) {\r\n            // The webhook can return a single user or an array of users\r\n            const userData = Array.isArray(response.data) ? response.data[0] : response.data;\r\n            if (userData) {\r\n                return {\r\n                    ...userData,\r\n                    userId: userData._id || userData.userId,\r\n                    roles: userData.roles || ['User']\r\n                };\r\n            }\r\n        }\r\n\r\n        console.warn(`Webhook returned status ${response.status} or no data for ${email}. Falling back to default user.`);\r\n        return createDefaultUser(email);\r\n\r\n    } catch (error) {\r\n        if (axios.isAxiosError(error)) {\r\n            if (error.response?.status === 404) {\r\n                 console.warn(`User not found via webhook (userId: ${email}). Falling back to default user.`);\r\n            } else {\r\n                 console.error(`Failed to get user profile from webhook for ${email}:`, error.message);\r\n            }\r\n        } else {\r\n            console.error('An unexpected error occurred:', error);\r\n        }\r\n        return createDefaultUser(email);\r\n    }\r\n}\r\n\r\nexport async function updateUserProfile(profileData: Partial<User>): Promise<boolean> {\r\n    const webhookUrl = getUpdateWebhookUrl();\r\n    if (!webhookUrl) {\r\n        console.error('Cannot update/create user profile: NEXT_PUBLIC_USER_PROFILE_UPDATE_WEBHOOK_URL is not configured.');\r\n        return false;\r\n    }\r\n\r\n    // Ensure we have an email for the userId\r\n    if (!profileData.email) {\r\n        console.error('Cannot update user profile: No email provided');\r\n        return false;\r\n    }\r\n\r\n    // Filter out null, undefined, and empty string values to preserve existing data\r\n    const cleanData: Partial<User> = {};\r\n    Object.keys(profileData).forEach(key => {\r\n        const value = profileData[key as keyof User];\r\n        // Skip username field - we'll generate it properly below\r\n        if (key === 'username') {\r\n            return;\r\n        }\r\n        // Only include values that are truthy and not empty strings\r\n        if (value !== null && value !== undefined && value !== '' && value !== 'null') {\r\n            cleanData[key as keyof User] = value;\r\n        }\r\n    });\r\n\r\n    // If we don't have any meaningful data to update, don't proceed\r\n    const hasValidData = Object.keys(cleanData).some(key => \r\n        key !== 'userId' && cleanData[key as keyof User] !== null && cleanData[key as keyof User] !== undefined\r\n    );\r\n\r\n    if (!hasValidData) {\r\n        console.error('No valid data to update profile with');\r\n        return false;\r\n    }\r\n\r\n    // Always generate clean username if we have first_name and last_name\r\n    if (cleanData.first_name && cleanData.last_name) {\r\n        // Clean the names of any special characters and generate proper username\r\n        const cleanFirstName = cleanData.first_name.replace(/[^a-zA-Z]/g, '').toLowerCase();\r\n        const cleanLastName = cleanData.last_name.replace(/[^a-zA-Z]/g, '').toLowerCase();\r\n        cleanData.username = `${cleanFirstName}.${cleanLastName}`;\r\n    }\r\n\r\n    // Always include email as userId to identify the record to update\r\n    cleanData.userId = profileData.email;\r\n\r\n    // Send the data directly (same as User Management does)\r\n    const payload = cleanData;\r\n\r\n    try {\r\n        const response = await axios.post(webhookUrl, payload);\r\n        return response.status === 200 || response.status === 201;\r\n    } catch (error) {\r\n        console.error('Failed to update user profile via webhook:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\nexport interface LoginResult {\r\n    success: boolean;\r\n    user?: User;\r\n    workspaces?: Workspace[];\r\n    error?: string;\r\n}\r\n\r\nexport async function performLogin(email: string, password: string): Promise<LoginResult> {\r\n    try {\r\n        // In a real app, you'd validate credentials against your auth service\r\n        // For now, we'll simulate successful validation and fetch user data\r\n        \r\n        const user = await getUserProfile(email);\r\n        if (!user) {\r\n            return {\r\n                success: false,\r\n                error: 'Failed to retrieve user profile'\r\n            };\r\n        }\r\n\r\n        const workspaces = await getWorkspaces(user.userId);\r\n        \r\n        // Store session data\r\n        const sessionData = {\r\n            loggedIn: true,\r\n            email: email,\r\n            userId: user.userId,\r\n            loginTime: new Date().toISOString()\r\n        };\r\n        \r\n        // Store in localStorage (this will be client-side when called from client)\r\n        if (typeof window !== 'undefined') {\r\n            localStorage.setItem('session', JSON.stringify(sessionData));\r\n            localStorage.setItem('userData', JSON.stringify({ user, workspaces }));\r\n        }\r\n        \r\n        return {\r\n            success: true,\r\n            user,\r\n            workspaces\r\n        };\r\n    } catch (error) {\r\n        console.error('Login failed:', error);\r\n        return {\r\n            success: false,\r\n            error: error instanceof Error ? error.message : 'Login failed'\r\n        };\r\n    }\r\n}\r\n\r\nexport function getCachedUserData(): { user: User | null; workspaces: Workspace[] } {\r\n    if (typeof window === 'undefined') {\r\n        return { user: null, workspaces: [] };\r\n    }\r\n    \r\n    try {\r\n        const cached = localStorage.getItem('userData');\r\n        if (cached) {\r\n            const data = JSON.parse(cached);\r\n            return {\r\n                user: data.user || null,\r\n                workspaces: data.workspaces || []\r\n            };\r\n        }\r\n    } catch (error) {\r\n        console.error('Failed to parse cached user data:', error);\r\n    }\r\n    \r\n    return { user: null, workspaces: [] };\r\n}\r\n\r\nexport function updateCachedWorkspaces(workspaces: Workspace[]): void {\r\n    if (typeof window === 'undefined') return;\r\n    \r\n    try {\r\n        const cached = localStorage.getItem('userData');\r\n        if (cached) {\r\n            const data = JSON.parse(cached);\r\n            data.workspaces = workspaces;\r\n            localStorage.setItem('userData', JSON.stringify(data));\r\n        }\r\n    } catch (error) {\r\n        console.error('Failed to update cached workspaces:', error);\r\n    }\r\n}\r\n\r\nexport function getCachedWorkspace(workspaceId: string): Workspace | null {\r\n    const { workspaces } = getCachedUserData();\r\n    return workspaces.find(ws => ws.workspaceId === workspaceId) || null;\r\n}\r\n\r\nexport function clearUserData(): void {\r\n    if (typeof window !== 'undefined') {\r\n        localStorage.removeItem('session');\r\n        localStorage.removeItem('userData');\r\n    }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 855, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/servicenow.ts"],"sourcesContent":["\r\n'use server';\r\n\r\nimport axios from 'axios';\r\nimport type { Incident } from '@/lib/types';\r\n\r\nexport async function getIncidents(serviceNowUrl?: string): Promise<Incident[]> {\r\n  const appClient = 'ai_browser';\r\n  const appSecret = 'Appdev2025!';\r\n  \r\n  // Use provided URL or fallback to hardcoded default\r\n  const baseUrl = serviceNowUrl || 'https://dev309119.service-now.com';\r\n  const requestUrl = `${baseUrl}/api/now/table/incident?sysparm_limit=10`;\r\n\r\n  // Create Basic Auth header\r\n  const auth = Buffer.from(`${appClient}:${appSecret}`).toString('base64');\r\n\r\n  try {\r\n    const response = await axios.get(requestUrl, {\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Accept': 'application/json',\r\n        'Authorization': `Basic ${auth}`,\r\n      },\r\n    });\r\n    return response.data.result;\r\n  } catch (error: any) {\r\n    console.error('ServiceNow API Error:', {\r\n      message: error.message,\r\n      status: error.response?.status,\r\n      statusText: error.response?.statusText,\r\n      data: error.response?.data\r\n    });\r\n    \r\n    // More specific error handling\r\n    if (error.response?.status === 401) {\r\n      throw new Error('Authentication failed. Check your ServiceNow credentials.');\r\n    } else if (error.response?.status === 403) {\r\n      throw new Error('Access forbidden. Check user permissions.');\r\n    } else {\r\n      throw new Error(`Failed to fetch data from ServiceNow: ${error.message}`);\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;IAMsB,eAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 868, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/sampleDataService.ts"],"sourcesContent":["\r\n'use server';\r\n\r\nimport axios from 'axios';\r\nimport type { Incident, Problem, Change } from '@/lib/types';\r\n\r\nconst getWebhookUrl = () => {\r\n    const url = process.env.SAMPLE_RECORD_WEBHOOK_URL;\r\n    if (!url) {\r\n        throw new Error('SAMPLE_RECORD_WEBHOOK_URL is not configured in .env file.');\r\n    }\r\n    return url;\r\n};\r\n\r\ntype DataType = 'incident' | 'problem' | 'change_request';\r\n\r\nexport async function getSampleData(type: DataType, sysId: string = 'all'): Promise<(Incident | Problem | Change)[]> {\r\n    const webhookUrl = getWebhookUrl();\r\n\r\n    try {\r\n        const response = await axios.get(webhookUrl, {\r\n            params: {\r\n                type: type,\r\n                sys_id: sysId,\r\n            },\r\n        });\r\n\r\n        if (response.status === 200 && response.data) {\r\n            return Array.isArray(response.data) ? response.data : [response.data];\r\n        }\r\n\r\n        console.warn(`Webhook for sample data returned status ${response.status} or no data.`);\r\n        return [];\r\n\r\n    } catch (error) {\r\n        if (axios.isAxiosError(error)) {\r\n            console.error(`Failed to get sample data from webhook for type ${type}:`, error.message);\r\n        } else {\r\n            console.error('An unexpected error occurred while fetching sample data:', error);\r\n        }\r\n        throw new Error(`Failed to fetch sample data for type: ${type}`);\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;IAgBsB,gBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 881, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/workspaceService.ts"],"sourcesContent":["\r\n\r\n'use server';\r\n\r\nimport axios from 'axios';\r\nimport type { Workspace } from '@/lib/types';\r\n\r\nconst getWorkspaceWebhookUrl = () => {\r\n    const url = process.env.WORKSPACE_WEBHOOK_URL;\r\n    if (!url) {\r\n        throw new Error('WORKSPACE_WEBHOOK_URL is not configured in .env file.');\r\n    }\r\n    return url;\r\n};\r\n\r\nconst getUserWorkspacesWebhookUrl = () => {\r\n    const url = process.env.USER_WORKSPACE_WEBHOOK_URL;\r\n    if (!url) {\r\n        console.warn('USER_WORKSPACE_WEBHOOK_URL is not configured in .env file - workspace sync disabled');\r\n        return null;\r\n    }\r\n    return url;\r\n};\r\n\r\nexport async function getWorkspaces(userId: string): Promise<Workspace[]> {\r\n    try {\r\n        const webhookUrl = getUserWorkspacesWebhookUrl();\r\n        if (!webhookUrl) {\r\n            return []; // Gracefully return empty array if webhook URL is not configured\r\n        }\r\n        const response = await axios.get(webhookUrl, { params: { userId, workspaceId: 'all' } });\r\n        if (response.status === 200 && response.data) {\r\n            return Array.isArray(response.data) ? response.data : [response.data];\r\n        }\r\n        return [];\r\n    } catch (error: any) {\r\n        // Only log detailed errors for non-404 status codes\r\n        if (error?.response?.status !== 404) {\r\n            console.error('Failed to get workspaces:', error);\r\n        } else {\r\n            console.warn('Workspace endpoint not found (404) - using local workspace management');\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport interface WorkspaceChanges {\r\n    added: Workspace[];\r\n    deleted: string[];\r\n    modified: Workspace[];\r\n    hasChanges: boolean;\r\n}\r\n\r\nexport async function detectWorkspaceChanges(userId: string, currentWorkspaces: Workspace[]): Promise<WorkspaceChanges> {\r\n    try {\r\n        const freshWorkspaces = await getWorkspaces(userId);\r\n        \r\n        const currentMap = new Map(currentWorkspaces.map(ws => [ws.workspaceId, ws]));\r\n        const freshMap = new Map(freshWorkspaces.map(ws => [ws.workspaceId, ws]));\r\n        \r\n        const added: Workspace[] = [];\r\n        const modified: Workspace[] = [];\r\n        const deleted: string[] = [];\r\n        \r\n        // Find added and modified workspaces\r\n        for (const [id, freshWs] of freshMap) {\r\n            const currentWs = currentMap.get(id);\r\n            if (!currentWs) {\r\n                added.push(freshWs);\r\n            } else if (JSON.stringify(currentWs) !== JSON.stringify(freshWs)) {\r\n                modified.push(freshWs);\r\n            }\r\n        }\r\n        \r\n        // Find deleted workspaces\r\n        for (const [id] of currentMap) {\r\n            if (!freshMap.has(id)) {\r\n                deleted.push(id);\r\n            }\r\n        }\r\n        \r\n        return {\r\n            added,\r\n            deleted,\r\n            modified,\r\n            hasChanges: added.length > 0 || deleted.length > 0 || modified.length > 0\r\n        };\r\n    } catch (error) {\r\n        console.error('Failed to detect workspace changes:', error);\r\n        return {\r\n            added: [],\r\n            deleted: [],\r\n            modified: [],\r\n            hasChanges: false\r\n        };\r\n    }\r\n}\r\n\r\n\r\nexport async function saveWorkspace(workspaceData: Omit<Workspace, 'workspaceId' | 'active'> & { workspaceId?: string }): Promise<Workspace | null> {\r\n    const webhookUrl = getWorkspaceWebhookUrl();\r\n    const workspaceId = workspaceData.workspaceId || `ws_${Date.now()}`;\r\n    const payload = {\r\n        ...workspaceData,\r\n        workspaceId: workspaceId,\r\n        active: true,\r\n    };\r\n\r\n\r\n    try {\r\n        const response = await axios.post(webhookUrl, payload, { params: { workspaceId } });\r\n        if (response.status === 200 || response.status === 201) {\r\n            // The webhook can return the saved object directly or inside a 'result' property\r\n            return response.data?.result || response.data;\r\n        }\r\n        return null;\r\n    } catch (error: any) {\r\n        if (axios.isAxiosError(error)) {\r\n            // Only log detailed errors for non-404 status codes\r\n            if (error?.response?.status !== 404) {\r\n                console.error('Failed to save workspace:', {\r\n                    message: error.message,\r\n                    status: error.response?.status,\r\n                    data: error.response?.data,\r\n                    url: webhookUrl,\r\n                    sentData: payload\r\n                });\r\n            } else {\r\n                console.warn('Workspace save endpoint not found (404) - workspace not saved to remote');\r\n            }\r\n        } else {\r\n            console.error('An unexpected error occurred during workspace save:', error);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function deleteWorkspace(workspaceId: string): Promise<boolean> {\r\n    const webhookUrl = getWorkspaceWebhookUrl();\r\n    try {\r\n        const response = await axios.delete(webhookUrl, { params: { workspaceId } });\r\n        return response.status === 200 || response.status === 204;\r\n    } catch (error: any) {\r\n        // Only log detailed errors for non-404 status codes\r\n        if (error?.response?.status !== 404) {\r\n            console.error('Failed to delete workspace:', error);\r\n        } else {\r\n            console.warn('Workspace delete endpoint not found (404) - workspace not deleted from remote');\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;IAmGsB,gBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 894, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/workspaceService.ts"],"sourcesContent":["\r\n\r\n'use server';\r\n\r\nimport axios from 'axios';\r\nimport type { Workspace } from '@/lib/types';\r\n\r\nconst getWorkspaceWebhookUrl = () => {\r\n    const url = process.env.WORKSPACE_WEBHOOK_URL;\r\n    if (!url) {\r\n        throw new Error('WORKSPACE_WEBHOOK_URL is not configured in .env file.');\r\n    }\r\n    return url;\r\n};\r\n\r\nconst getUserWorkspacesWebhookUrl = () => {\r\n    const url = process.env.USER_WORKSPACE_WEBHOOK_URL;\r\n    if (!url) {\r\n        console.warn('USER_WORKSPACE_WEBHOOK_URL is not configured in .env file - workspace sync disabled');\r\n        return null;\r\n    }\r\n    return url;\r\n};\r\n\r\nexport async function getWorkspaces(userId: string): Promise<Workspace[]> {\r\n    try {\r\n        const webhookUrl = getUserWorkspacesWebhookUrl();\r\n        if (!webhookUrl) {\r\n            return []; // Gracefully return empty array if webhook URL is not configured\r\n        }\r\n        const response = await axios.get(webhookUrl, { params: { userId, workspaceId: 'all' } });\r\n        if (response.status === 200 && response.data) {\r\n            return Array.isArray(response.data) ? response.data : [response.data];\r\n        }\r\n        return [];\r\n    } catch (error: any) {\r\n        // Only log detailed errors for non-404 status codes\r\n        if (error?.response?.status !== 404) {\r\n            console.error('Failed to get workspaces:', error);\r\n        } else {\r\n            console.warn('Workspace endpoint not found (404) - using local workspace management');\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport interface WorkspaceChanges {\r\n    added: Workspace[];\r\n    deleted: string[];\r\n    modified: Workspace[];\r\n    hasChanges: boolean;\r\n}\r\n\r\nexport async function detectWorkspaceChanges(userId: string, currentWorkspaces: Workspace[]): Promise<WorkspaceChanges> {\r\n    try {\r\n        const freshWorkspaces = await getWorkspaces(userId);\r\n        \r\n        const currentMap = new Map(currentWorkspaces.map(ws => [ws.workspaceId, ws]));\r\n        const freshMap = new Map(freshWorkspaces.map(ws => [ws.workspaceId, ws]));\r\n        \r\n        const added: Workspace[] = [];\r\n        const modified: Workspace[] = [];\r\n        const deleted: string[] = [];\r\n        \r\n        // Find added and modified workspaces\r\n        for (const [id, freshWs] of freshMap) {\r\n            const currentWs = currentMap.get(id);\r\n            if (!currentWs) {\r\n                added.push(freshWs);\r\n            } else if (JSON.stringify(currentWs) !== JSON.stringify(freshWs)) {\r\n                modified.push(freshWs);\r\n            }\r\n        }\r\n        \r\n        // Find deleted workspaces\r\n        for (const [id] of currentMap) {\r\n            if (!freshMap.has(id)) {\r\n                deleted.push(id);\r\n            }\r\n        }\r\n        \r\n        return {\r\n            added,\r\n            deleted,\r\n            modified,\r\n            hasChanges: added.length > 0 || deleted.length > 0 || modified.length > 0\r\n        };\r\n    } catch (error) {\r\n        console.error('Failed to detect workspace changes:', error);\r\n        return {\r\n            added: [],\r\n            deleted: [],\r\n            modified: [],\r\n            hasChanges: false\r\n        };\r\n    }\r\n}\r\n\r\n\r\nexport async function saveWorkspace(workspaceData: Omit<Workspace, 'workspaceId' | 'active'> & { workspaceId?: string }): Promise<Workspace | null> {\r\n    const webhookUrl = getWorkspaceWebhookUrl();\r\n    const workspaceId = workspaceData.workspaceId || `ws_${Date.now()}`;\r\n    const payload = {\r\n        ...workspaceData,\r\n        workspaceId: workspaceId,\r\n        active: true,\r\n    };\r\n\r\n\r\n    try {\r\n        const response = await axios.post(webhookUrl, payload, { params: { workspaceId } });\r\n        if (response.status === 200 || response.status === 201) {\r\n            // The webhook can return the saved object directly or inside a 'result' property\r\n            return response.data?.result || response.data;\r\n        }\r\n        return null;\r\n    } catch (error: any) {\r\n        if (axios.isAxiosError(error)) {\r\n            // Only log detailed errors for non-404 status codes\r\n            if (error?.response?.status !== 404) {\r\n                console.error('Failed to save workspace:', {\r\n                    message: error.message,\r\n                    status: error.response?.status,\r\n                    data: error.response?.data,\r\n                    url: webhookUrl,\r\n                    sentData: payload\r\n                });\r\n            } else {\r\n                console.warn('Workspace save endpoint not found (404) - workspace not saved to remote');\r\n            }\r\n        } else {\r\n            console.error('An unexpected error occurred during workspace save:', error);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function deleteWorkspace(workspaceId: string): Promise<boolean> {\r\n    const webhookUrl = getWorkspaceWebhookUrl();\r\n    try {\r\n        const response = await axios.delete(webhookUrl, { params: { workspaceId } });\r\n        return response.status === 200 || response.status === 204;\r\n    } catch (error: any) {\r\n        // Only log detailed errors for non-404 status codes\r\n        if (error?.response?.status !== 404) {\r\n            console.error('Failed to delete workspace:', error);\r\n        } else {\r\n            console.warn('Workspace delete endpoint not found (404) - workspace not deleted from remote');\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;IAyIsB,kBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 907, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/workspaceService.ts"],"sourcesContent":["\r\n\r\n'use server';\r\n\r\nimport axios from 'axios';\r\nimport type { Workspace } from '@/lib/types';\r\n\r\nconst getWorkspaceWebhookUrl = () => {\r\n    const url = process.env.WORKSPACE_WEBHOOK_URL;\r\n    if (!url) {\r\n        throw new Error('WORKSPACE_WEBHOOK_URL is not configured in .env file.');\r\n    }\r\n    return url;\r\n};\r\n\r\nconst getUserWorkspacesWebhookUrl = () => {\r\n    const url = process.env.USER_WORKSPACE_WEBHOOK_URL;\r\n    if (!url) {\r\n        console.warn('USER_WORKSPACE_WEBHOOK_URL is not configured in .env file - workspace sync disabled');\r\n        return null;\r\n    }\r\n    return url;\r\n};\r\n\r\nexport async function getWorkspaces(userId: string): Promise<Workspace[]> {\r\n    try {\r\n        const webhookUrl = getUserWorkspacesWebhookUrl();\r\n        if (!webhookUrl) {\r\n            return []; // Gracefully return empty array if webhook URL is not configured\r\n        }\r\n        const response = await axios.get(webhookUrl, { params: { userId, workspaceId: 'all' } });\r\n        if (response.status === 200 && response.data) {\r\n            return Array.isArray(response.data) ? response.data : [response.data];\r\n        }\r\n        return [];\r\n    } catch (error: any) {\r\n        // Only log detailed errors for non-404 status codes\r\n        if (error?.response?.status !== 404) {\r\n            console.error('Failed to get workspaces:', error);\r\n        } else {\r\n            console.warn('Workspace endpoint not found (404) - using local workspace management');\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport interface WorkspaceChanges {\r\n    added: Workspace[];\r\n    deleted: string[];\r\n    modified: Workspace[];\r\n    hasChanges: boolean;\r\n}\r\n\r\nexport async function detectWorkspaceChanges(userId: string, currentWorkspaces: Workspace[]): Promise<WorkspaceChanges> {\r\n    try {\r\n        const freshWorkspaces = await getWorkspaces(userId);\r\n        \r\n        const currentMap = new Map(currentWorkspaces.map(ws => [ws.workspaceId, ws]));\r\n        const freshMap = new Map(freshWorkspaces.map(ws => [ws.workspaceId, ws]));\r\n        \r\n        const added: Workspace[] = [];\r\n        const modified: Workspace[] = [];\r\n        const deleted: string[] = [];\r\n        \r\n        // Find added and modified workspaces\r\n        for (const [id, freshWs] of freshMap) {\r\n            const currentWs = currentMap.get(id);\r\n            if (!currentWs) {\r\n                added.push(freshWs);\r\n            } else if (JSON.stringify(currentWs) !== JSON.stringify(freshWs)) {\r\n                modified.push(freshWs);\r\n            }\r\n        }\r\n        \r\n        // Find deleted workspaces\r\n        for (const [id] of currentMap) {\r\n            if (!freshMap.has(id)) {\r\n                deleted.push(id);\r\n            }\r\n        }\r\n        \r\n        return {\r\n            added,\r\n            deleted,\r\n            modified,\r\n            hasChanges: added.length > 0 || deleted.length > 0 || modified.length > 0\r\n        };\r\n    } catch (error) {\r\n        console.error('Failed to detect workspace changes:', error);\r\n        return {\r\n            added: [],\r\n            deleted: [],\r\n            modified: [],\r\n            hasChanges: false\r\n        };\r\n    }\r\n}\r\n\r\n\r\nexport async function saveWorkspace(workspaceData: Omit<Workspace, 'workspaceId' | 'active'> & { workspaceId?: string }): Promise<Workspace | null> {\r\n    const webhookUrl = getWorkspaceWebhookUrl();\r\n    const workspaceId = workspaceData.workspaceId || `ws_${Date.now()}`;\r\n    const payload = {\r\n        ...workspaceData,\r\n        workspaceId: workspaceId,\r\n        active: true,\r\n    };\r\n\r\n\r\n    try {\r\n        const response = await axios.post(webhookUrl, payload, { params: { workspaceId } });\r\n        if (response.status === 200 || response.status === 201) {\r\n            // The webhook can return the saved object directly or inside a 'result' property\r\n            return response.data?.result || response.data;\r\n        }\r\n        return null;\r\n    } catch (error: any) {\r\n        if (axios.isAxiosError(error)) {\r\n            // Only log detailed errors for non-404 status codes\r\n            if (error?.response?.status !== 404) {\r\n                console.error('Failed to save workspace:', {\r\n                    message: error.message,\r\n                    status: error.response?.status,\r\n                    data: error.response?.data,\r\n                    url: webhookUrl,\r\n                    sentData: payload\r\n                });\r\n            } else {\r\n                console.warn('Workspace save endpoint not found (404) - workspace not saved to remote');\r\n            }\r\n        } else {\r\n            console.error('An unexpected error occurred during workspace save:', error);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function deleteWorkspace(workspaceId: string): Promise<boolean> {\r\n    const webhookUrl = getWorkspaceWebhookUrl();\r\n    try {\r\n        const response = await axios.delete(webhookUrl, { params: { workspaceId } });\r\n        return response.status === 200 || response.status === 204;\r\n    } catch (error: any) {\r\n        // Only log detailed errors for non-404 status codes\r\n        if (error?.response?.status !== 404) {\r\n            console.error('Failed to delete workspace:', error);\r\n        } else {\r\n            console.warn('Workspace delete endpoint not found (404) - workspace not deleted from remote');\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;IAqDsB,yBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 920, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/assistantService.ts"],"sourcesContent":["\r\n'use server';\r\n\r\nimport axios from 'axios';\r\nimport type { Assistant } from '@/lib/types';\r\n\r\nconst ASSISTANTS_CACHE_KEY = 'assistantsCache';\r\nlet cache: { timestamp: number; data: Assistant[] } | null = null;\r\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\r\n\r\nconst getWebhookUrl = () => {\r\n    const url = process.env.GET_OPENAI_ASSISTANTS;\r\n    if (!url) {\r\n        console.warn('GET_OPENAI_ASSISTANTS webhook URL is not configured. Assistant fetching will be skipped.');\r\n        return null;\r\n    }\r\n    return url;\r\n};\r\n\r\nconst getSampleAssistants = (): Assistant[] => [\r\n    {\r\n        id: '1',\r\n        name: 'ODIN (Sample)',\r\n        description: 'You are a helpful assistant named ODIN, you are a meta-agent.... (This is sample data)',\r\n        version: 'gpt-4.1',\r\n        icon: 'bot',\r\n        addedDate: '2023-10-26T10:00:00Z',\r\n    },\r\n    {\r\n        id: '2',\r\n        name: 'Prompt Architect (Sample)',\r\n        description: 'You are a Prompt Architect AI. Your job is to write optimized system prompts...',\r\n        version: 'gpt-4.1',\r\n        icon: 'zap',\r\n        addedDate: '2023-10-25T10:00:00Z',\r\n    },\r\n];\r\n\r\nexport async function getAssistants(forceRefresh = false): Promise<Assistant[]> {\r\n    const now = Date.now();\r\n    if (!forceRefresh && cache && (now - cache.timestamp < CACHE_DURATION)) {\r\n        return cache.data;\r\n    }\r\n\r\n    const webhookUrl = getWebhookUrl();\r\n    const apiKey = process.env.BABLEPHISH_ASSISTANT_API_KEY;\r\n\r\n    if (!webhookUrl) {\r\n        return getSampleAssistants();\r\n    }\r\n    \r\n    if (!apiKey) {\r\n        console.warn('BABLEPHISH_ASSISTANT_API_KEY is not configured. Falling back to sample data.');\r\n        return getSampleAssistants();\r\n    }\r\n\r\n    try {\r\n        const response = await axios.get(webhookUrl, {\r\n            headers: {\r\n                'Authorization': `Bearer ${apiKey}`,\r\n                'OpenAI-Beta': 'assistants=v1'\r\n            },\r\n        });\r\n\r\n        if (response.status === 200 && response.data) {\r\n            // The API can return an object with a 'data' property or a direct array\r\n            const assistantList = Array.isArray(response.data) ? response.data : response.data.data;\r\n\r\n            if (Array.isArray(assistantList)) {\r\n                const assistants = assistantList.map((item: any) => ({\r\n                    id: item.id,\r\n                    name: item.name || 'Unnamed Assistant',\r\n                    description: item.instructions || 'No description provided.',\r\n                    version: item.model || 'N/A',\r\n                    icon: item.tools?.length > 0 ? 'zap' : 'bot',\r\n                    addedDate: item.created_at ? new Date(item.created_at * 1000).toISOString() : new Date().toISOString()\r\n                }));\r\n\r\n                cache = { timestamp: now, data: assistants };\r\n                return assistants;\r\n            }\r\n        }\r\n\r\n        console.warn(`Webhook for assistants returned status ${response.status} or invalid data format.`, response.data);\r\n        return getSampleAssistants();\r\n\r\n    } catch (error) {\r\n        if (axios.isAxiosError(error)) {\r\n            console.error('Failed to get assistants from webhook:', error.message);\r\n        } else {\r\n            console.error('An unexpected error occurred while fetching assistants:', error);\r\n        }\r\n        return getSampleAssistants();\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;IAsCsB,gBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 933, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/promptService.ts"],"sourcesContent":["\r\n'use server';\r\n\r\nimport axios from 'axios';\r\nimport type { Prompt } from '@/lib/types';\r\n\r\nconst getWebhookUrl = () => {\r\n    const url = process.env.GET_PROMPT_WEBHOOK_URL;\r\n    if (!url) {\r\n        console.warn('GET_PROMPT_WEBHOOK_URL is not configured in .env file. Prompt fetching will be skipped.');\r\n        return null;\r\n    }\r\n    return url;\r\n};\r\n\r\nexport async function getPrompts(): Promise<Prompt[]> {\r\n    const webhookUrl = getWebhookUrl();\r\n    if (!webhookUrl) {\r\n        return []; // Return empty array if URL is not set\r\n    }\r\n\r\n    try {\r\n        const response = await axios.get(webhookUrl);\r\n\r\n        if (response.status === 200 && response.data) {\r\n            return Array.isArray(response.data) ? response.data : [response.data];\r\n        }\r\n\r\n        console.warn(`Webhook for prompts returned status ${response.status} or no data.`);\r\n        return [];\r\n\r\n    } catch (error) {\r\n        if (axios.isAxiosError(error)) {\r\n            console.error('Failed to get prompts from webhook:', error.message);\r\n        } else {\r\n            console.error('An unexpected error occurred while fetching prompts:', error);\r\n        }\r\n        // Instead of throwing, return empty array to allow the page to render.\r\n        return [];\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;IAesB,aAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 946, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/roleService.ts"],"sourcesContent":["interface Role {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  userCount: number;\r\n  permissions: string[];\r\n  createdAt: string;\r\n  active?: boolean;\r\n}\r\n\r\ninterface CreateRoleRequest {\r\n  name: string;\r\n  description: string;\r\n  permissions: string[];\r\n}\r\n\r\ninterface UpdateRoleRequest extends CreateRoleRequest {\r\n  id: string;\r\n}\r\n\r\nclass RoleService {\r\n  private async retryRequest<T>(\r\n    requestFn: () => Promise<T>, \r\n    maxRetries: number = 2, \r\n    delay: number = 1000\r\n  ): Promise<T> {\r\n    let lastError: Error;\r\n    \r\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        return await requestFn();\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n        \r\n        // Don't retry for non-network errors\r\n        if (!(error instanceof TypeError && error.message === 'Failed to fetch')) {\r\n          throw error;\r\n        }\r\n        \r\n        if (attempt < maxRetries) {\r\n          console.log(`Request failed, retrying in ${delay}ms (attempt ${attempt + 1}/${maxRetries + 1})`);\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          delay *= 1.5; // Exponential backoff\r\n        }\r\n      }\r\n    }\r\n    \r\n    throw lastError!;\r\n  }\r\n\r\n  private getWebhookUrl(type: 'get' | 'create_update' | 'delete'): string {\r\n    switch (type) {\r\n      case 'get':\r\n        return process.env.NEXT_PUBLIC_GET_ROLES_WEBHOOK_URL || '';\r\n      case 'create_update':\r\n        return process.env.NEXT_PUBLIC_CREATE_UPDATE_ROLE_WEBHOOK_URL || '';\r\n      case 'delete':\r\n        return process.env.NEXT_PUBLIC_DELETE_ROLE_WEBHOOK_URL || '';\r\n      default:\r\n        return '';\r\n    }\r\n  }\r\n\r\n  private async makeRequest<T>(url: string, options: RequestInit = {}): Promise<T> {\r\n    if (!url) {\r\n      console.error('Webhook URL not configured. Available env vars:', {\r\n        get: process.env.NEXT_PUBLIC_GET_ROLES_WEBHOOK_URL,\r\n        create_update: process.env.NEXT_PUBLIC_CREATE_UPDATE_ROLE_WEBHOOK_URL,\r\n        delete: process.env.NEXT_PUBLIC_DELETE_ROLE_WEBHOOK_URL\r\n      });\r\n      throw new Error('Webhook URL not configured');\r\n    }\r\n\r\n    console.log('Making request to:', url, 'with options:', options);\r\n\r\n    try {\r\n      const response = await fetch(url, {\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          ...options.headers,\r\n        },\r\n        ...options,\r\n      });\r\n\r\n      console.log('Response status:', response.status);\r\n      console.log('Response headers:', Object.fromEntries(response.headers.entries()));\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        console.error(`HTTP Error ${response.status}:`, errorText);\r\n        throw new Error(`HTTP ${response.status}: ${errorText}`);\r\n      }\r\n\r\n      const jsonResponse = await response.json();\r\n      console.log('JSON Response received:', jsonResponse);\r\n      return jsonResponse;\r\n    } catch (error) {\r\n      // Handle network errors specifically\r\n      if (error instanceof TypeError && error.message === 'Failed to fetch') {\r\n        console.error('Network error - Failed to fetch. This could be due to:');\r\n        console.error('1. Network connectivity issues');\r\n        console.error('2. CORS policy blocking the request');\r\n        console.error('3. Server is unreachable');\r\n        console.error('4. SSL/TLS certificate issues');\r\n        console.error('Request details:', { url, method: options.method || 'GET' });\r\n        throw new Error(`Network error: Unable to reach ${url}. Please check your internet connection and server status.`);\r\n      }\r\n      \r\n      // Re-throw other errors\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private getSampleRoles(): Role[] {\r\n    return [\r\n      {\r\n        id: 'sample-admin',\r\n        name: 'Administrator',\r\n        description: 'Full system access with all permissions',\r\n        userCount: 3,\r\n        permissions: ['User Management', 'Role Management', 'System Settings', 'View Reports', 'Export Data', 'Import Data', 'Manage Workspaces', 'AI Tools Access', 'Admin Panel'],\r\n        createdAt: new Date().toLocaleDateString('en-GB'),\r\n        active: true\r\n      },\r\n      {\r\n        id: 'sample-user',\r\n        name: 'Standard User',\r\n        description: 'Basic user with limited permissions',\r\n        userCount: 15,\r\n        permissions: ['View Reports', 'AI Tools Access'],\r\n        createdAt: new Date().toLocaleDateString('en-GB'),\r\n        active: true\r\n      },\r\n      {\r\n        id: 'sample-manager',\r\n        name: 'Manager',\r\n        description: 'Managerial role with workspace and reporting access',\r\n        userCount: 7,\r\n        permissions: ['View Reports', 'Export Data', 'Manage Workspaces', 'AI Tools Access'],\r\n        createdAt: new Date().toLocaleDateString('en-GB'),\r\n        active: true\r\n      }\r\n    ];\r\n  }\r\n\r\n  async getRoles(): Promise<Role[]> {\r\n    const url = this.getWebhookUrl('get');\r\n    \r\n    // If URL is not configured, return sample data\r\n    if (!url) {\r\n      console.log('Webhook URL not configured, returning sample roles');\r\n      return this.getSampleRoles();\r\n    }\r\n    \r\n    try {\r\n      const response = await this.makeRequest<any>(url, {\r\n        method: 'GET',\r\n      });\r\n      \r\n      let roles: Role[] = [];\r\n      \r\n      if (Array.isArray(response)) {\r\n        roles = response;\r\n      } else if (response && typeof response === 'object') {\r\n        roles = response.roles || response.data || response.items || response.result || [];\r\n        if (roles.length === 0) {\r\n          const values = Object.values(response);\r\n          if (values.length > 0 && Array.isArray(values[0])) {\r\n            roles = values[0] as Role[];\r\n          }\r\n        }\r\n      }\r\n      \r\n      const processedRoles = roles.map((role: any) => {\r\n        let permissions: string[] = [];\r\n        if (typeof role.permissions === 'string') {\r\n          try {\r\n            permissions = JSON.parse(role.permissions);\r\n          } catch (e) {\r\n            permissions = [];\r\n          }\r\n        } else if (Array.isArray(role.permissions)) {\r\n          permissions = role.permissions;\r\n        }\r\n\r\n        return {\r\n          id: role.id || role._id?.$oid || role._id || String(Math.random()),\r\n          name: role.name || role.roleName || 'Unknown Role',\r\n          description: role.description || role.desc || '',\r\n          userCount: role.userCount || role.users || 0,\r\n          permissions: permissions,\r\n          createdAt: role.createdAt || role.created || new Date().toLocaleDateString('en-GB'),\r\n          active: role.active === 'True' || role.active === true\r\n        };\r\n      });\r\n      \r\n      return processedRoles;\r\n    } catch (error) {\r\n      console.error('Error fetching roles from webhook:', error);\r\n      // On error, return an empty array to avoid showing sample data\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async createRole(roleData: CreateRoleRequest): Promise<Role> {\r\n    const url = this.getWebhookUrl('create_update');\r\n    \r\n    // If URL is not configured, return a mock created role\r\n    if (!url) {\r\n      console.log('Create webhook URL not configured, returning mock role');\r\n      const newId = crypto.randomUUID();\r\n      const mockRole: Role = {\r\n        id: newId,\r\n        name: roleData.name,\r\n        description: roleData.description,\r\n        userCount: 0,\r\n        permissions: roleData.permissions,\r\n        createdAt: new Date().toLocaleDateString('en-GB'),\r\n        active: true\r\n      };\r\n      return mockRole;\r\n    }\r\n    \r\n    try {\r\n      const response = await this.retryRequest(async () => {\r\n        // Convert permissions array to JSON string for database storage\r\n        const newId = crypto.randomUUID();\r\n        const payload = {\r\n          id: newId,\r\n          name: roleData.name,\r\n          description: roleData.description,\r\n          permissions: JSON.stringify(roleData.permissions),\r\n          active: \"True\",\r\n          userCount: 0,\r\n          createdAt: new Date().toLocaleDateString('en-GB')\r\n        };\r\n        \r\n        console.log('Creating role with payload:', payload);\r\n        \r\n        return await this.makeRequest<{ role?: Role; data?: Role }>(url, {\r\n          method: 'POST',\r\n          body: JSON.stringify(payload),\r\n        });\r\n      });\r\n      \r\n      console.log('Create role response:', response);\r\n      \r\n      const createdRole = response.role || response.data || response;\r\n      if (!createdRole) {\r\n        console.error('Failed to extract role from response:', response);\r\n        throw new Error('Invalid response format: missing role data');\r\n      }\r\n      \r\n      console.log('Successfully created role:', createdRole);\r\n      return createdRole;\r\n    } catch (error) {\r\n      console.error('Error creating role, falling back to mock data:', error);\r\n      // Return a mock role when webhook fails\r\n      const newId = crypto.randomUUID();\r\n      const mockRole: Role = {\r\n        id: newId,\r\n        name: roleData.name,\r\n        description: roleData.description,\r\n        userCount: 0,\r\n        permissions: roleData.permissions,\r\n        createdAt: new Date().toLocaleDateString('en-GB'),\r\n        active: true\r\n      };\r\n      return mockRole;\r\n    }\r\n  }\r\n\r\n  async updateRole(roleData: UpdateRoleRequest): Promise<Role> {\r\n    const url = this.getWebhookUrl('create_update');\r\n    \r\n    // If URL is not configured, return a mock updated role\r\n    if (!url) {\r\n      console.log('Update webhook URL not configured, returning mock updated role');\r\n      const mockRole: Role = {\r\n        id: roleData.id,\r\n        name: roleData.name,\r\n        description: roleData.description,\r\n        userCount: 0,\r\n        permissions: roleData.permissions,\r\n        createdAt: new Date().toLocaleDateString('en-GB'),\r\n        active: true\r\n      };\r\n      return mockRole;\r\n    }\r\n    \r\n    try {\r\n      const response = await this.retryRequest(async () => {\r\n        // Convert permissions array to JSON string for database storage\r\n        const payload = {\r\n          id: roleData.id,\r\n          name: roleData.name,\r\n          description: roleData.description,\r\n          permissions: JSON.stringify(roleData.permissions),\r\n          active: \"True\" // Maintain active status\r\n        };\r\n        \r\n        console.log('Updating role with payload:', payload);\r\n        \r\n        return await this.makeRequest<{ role?: Role; data?: Role }>(url, {\r\n          method: 'PUT',\r\n          body: JSON.stringify(payload),\r\n        });\r\n      });\r\n      \r\n      console.log('Update role response:', response);\r\n      \r\n      const updatedRole = response.role || response.data || response;\r\n      if (!updatedRole) {\r\n        console.error('Failed to extract role from response:', response);\r\n        throw new Error('Invalid response format: missing role data');\r\n      }\r\n      \r\n      console.log('Successfully updated role:', updatedRole);\r\n      return updatedRole;\r\n    } catch (error) {\r\n      console.error('Error updating role, falling back to mock data:', error);\r\n      // Return a mock updated role when webhook fails\r\n      const mockRole: Role = {\r\n        id: roleData.id,\r\n        name: roleData.name,\r\n        description: roleData.description,\r\n        userCount: 0,\r\n        permissions: roleData.permissions,\r\n        createdAt: new Date().toLocaleDateString('en-GB'),\r\n        active: true\r\n      };\r\n      return mockRole;\r\n    }\r\n  }\r\n\r\n  async deleteRole(roleId: string): Promise<void> {\r\n    const url = this.getWebhookUrl('delete');\r\n    \r\n    // If URL is not configured, just log and return (mock deletion)\r\n    if (!url) {\r\n      console.log('Delete webhook URL not configured, mock deleting role:', roleId);\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      await this.retryRequest(async () => {\r\n        console.log('Deleting role with ID:', roleId);\r\n        \r\n        const response = await this.makeRequest<{ success?: boolean; message?: string }>(url, {\r\n          method: 'DELETE',\r\n          body: JSON.stringify({ id: roleId }),\r\n        });\r\n        \r\n        console.log('Delete role response:', response);\r\n        return response;\r\n      });\r\n    } catch (error) {\r\n      console.error('Error deleting role, treating as successful (mock deletion):', error);\r\n      // Don't throw error for delete operations in fallback mode\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\n// Debug function to test all role webhooks\r\nexport const testRoleWebhooks = async () => {\r\n  console.log('=== TESTING ALL ROLE WEBHOOKS ===');\r\n  \r\n  const webhooks = {\r\n    get: process.env.NEXT_PUBLIC_GET_ROLES_WEBHOOK_URL,\r\n    create_update: process.env.NEXT_PUBLIC_CREATE_UPDATE_ROLE_WEBHOOK_URL,\r\n    delete: process.env.NEXT_PUBLIC_DELETE_ROLE_WEBHOOK_URL\r\n  };\r\n  \r\n  console.log('Configured webhook URLs:', webhooks);\r\n  \r\n  // Test GET endpoint\r\n  if (webhooks.get) {\r\n    console.log('\\n--- Testing GET roles endpoint ---');\r\n    try {\r\n      const response = await fetch(webhooks.get, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n      });\r\n      \r\n      console.log('GET Response status:', response.status);\r\n      console.log('GET Response headers:', Object.fromEntries(response.headers.entries()));\r\n      \r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        console.log('GET Response data:', data);\r\n        console.log('Data type:', typeof data);\r\n        console.log('Is Array:', Array.isArray(data));\r\n        if (data && typeof data === 'object') {\r\n          console.log('Data keys:', Object.keys(data));\r\n        }\r\n      } else {\r\n        const errorText = await response.text();\r\n        console.error('GET Error response:', errorText);\r\n      }\r\n    } catch (error) {\r\n      console.error('GET Request failed:', error);\r\n    }\r\n  } else {\r\n    console.log('GET webhook URL not configured');\r\n  }\r\n  \r\n  // Test CREATE endpoint with sample data\r\n  if (webhooks.create_update) {\r\n    console.log('\\n--- Testing CREATE endpoint ---');\r\n    const testPayload = {\r\n      name: \"Test Role\",\r\n      description: \"Test Description\",\r\n      permissions: JSON.stringify([\"User Management\"]),\r\n      active: \"True\",\r\n      userCount: 0\r\n    };\r\n    \r\n    console.log('Test payload:', testPayload);\r\n    \r\n    try {\r\n      const response = await fetch(webhooks.create_update, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(testPayload)\r\n      });\r\n      \r\n      console.log('CREATE Response status:', response.status);\r\n      console.log('CREATE Response headers:', Object.fromEntries(response.headers.entries()));\r\n      \r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        console.log('CREATE Response data:', data);\r\n      } else {\r\n        const errorText = await response.text();\r\n        console.error('CREATE Error response:', errorText);\r\n      }\r\n    } catch (error) {\r\n      console.error('CREATE Request failed:', error);\r\n    }\r\n  } else {\r\n    console.log('CREATE/UPDATE webhook URL not configured');\r\n  }\r\n  \r\n  console.log('=== WEBHOOK TEST COMPLETE ===');\r\n};\r\n\r\n// Legacy function for backwards compatibility\r\nexport const testRoleWebhook = testRoleWebhooks;\r\n\r\nexport const roleService = new RoleService();\r\nexport type { Role, CreateRoleRequest, UpdateRoleRequest };"],"names":[],"mappings":";;;;;AAoBA,MAAM;IACJ,MAAc,aACZ,SAA2B,EAC3B,aAAqB,CAAC,EACtB,QAAgB,IAAI,EACR;QACZ,IAAI;QAEJ,IAAK,IAAI,UAAU,GAAG,WAAW,YAAY,UAAW;YACtD,IAAI;gBACF,OAAO,MAAM;YACf,EAAE,OAAO,OAAO;gBACd,YAAY;gBAEZ,qCAAqC;gBACrC,IAAI,CAAC,CAAC,iBAAiB,aAAa,MAAM,OAAO,KAAK,iBAAiB,GAAG;oBACxE,MAAM;gBACR;gBAEA,IAAI,UAAU,YAAY;oBACxB,QAAQ,GAAG,CAAC,CAAC,4BAA4B,EAAE,MAAM,YAAY,EAAE,UAAU,EAAE,CAAC,EAAE,aAAa,EAAE,CAAC,CAAC;oBAC/F,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;oBACjD,SAAS,KAAK,sBAAsB;gBACtC;YACF;QACF;QAEA,MAAM;IACR;IAEQ,cAAc,IAAwC,EAAU;QACtE,OAAQ;YACN,KAAK;gBACH,OAAO,8FAAiD;YAC1D,KAAK;gBACH,OAAO,4FAA0D;YACnE,KAAK;gBACH,OAAO,4FAAmD;YAC5D;gBACE,OAAO;QACX;IACF;IAEA,MAAc,YAAe,GAAW,EAAE,UAAuB,CAAC,CAAC,EAAc;QAC/E,IAAI,CAAC,KAAK;YACR,QAAQ,KAAK,CAAC,mDAAmD;gBAC/D,GAAG;gBACH,aAAa;gBACb,MAAM;YACR;YACA,MAAM,IAAI,MAAM;QAClB;QAEA,QAAQ,GAAG,CAAC,sBAAsB,KAAK,iBAAiB;QAExD,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,KAAK;gBAChC,SAAS;oBACP,gBAAgB;oBAChB,GAAG,QAAQ,OAAO;gBACpB;gBACA,GAAG,OAAO;YACZ;YAEA,QAAQ,GAAG,CAAC,oBAAoB,SAAS,MAAM;YAC/C,QAAQ,GAAG,CAAC,qBAAqB,OAAO,WAAW,CAAC,SAAS,OAAO,CAAC,OAAO;YAE5E,IAAI,CAAC,SAAS,EAAE,EAAE;gBAChB,MAAM,YAAY,MAAM,SAAS,IAAI;gBACrC,QAAQ,KAAK,CAAC,CAAC,WAAW,EAAE,SAAS,MAAM,CAAC,CAAC,CAAC,EAAE;gBAChD,MAAM,IAAI,MAAM,CAAC,KAAK,EAAE,SAAS,MAAM,CAAC,EAAE,EAAE,WAAW;YACzD;YAEA,MAAM,eAAe,MAAM,SAAS,IAAI;YACxC,QAAQ,GAAG,CAAC,2BAA2B;YACvC,OAAO;QACT,EAAE,OAAO,OAAO;YACd,qCAAqC;YACrC,IAAI,iBAAiB,aAAa,MAAM,OAAO,KAAK,mBAAmB;gBACrE,QAAQ,KAAK,CAAC;gBACd,QAAQ,KAAK,CAAC;gBACd,QAAQ,KAAK,CAAC;gBACd,QAAQ,KAAK,CAAC;gBACd,QAAQ,KAAK,CAAC;gBACd,QAAQ,KAAK,CAAC,oBAAoB;oBAAE;oBAAK,QAAQ,QAAQ,MAAM,IAAI;gBAAM;gBACzE,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,IAAI,0DAA0D,CAAC;YACnH;YAEA,wBAAwB;YACxB,MAAM;QACR;IACF;IAEQ,iBAAyB;QAC/B,OAAO;YACL;gBACE,IAAI;gBACJ,MAAM;gBACN,aAAa;gBACb,WAAW;gBACX,aAAa;oBAAC;oBAAmB;oBAAmB;oBAAmB;oBAAgB;oBAAe;oBAAe;oBAAqB;oBAAmB;iBAAc;gBAC3K,WAAW,IAAI,OAAO,kBAAkB,CAAC;gBACzC,QAAQ;YACV;YACA;gBACE,IAAI;gBACJ,MAAM;gBACN,aAAa;gBACb,WAAW;gBACX,aAAa;oBAAC;oBAAgB;iBAAkB;gBAChD,WAAW,IAAI,OAAO,kBAAkB,CAAC;gBACzC,QAAQ;YACV;YACA;gBACE,IAAI;gBACJ,MAAM;gBACN,aAAa;gBACb,WAAW;gBACX,aAAa;oBAAC;oBAAgB;oBAAe;oBAAqB;iBAAkB;gBACpF,WAAW,IAAI,OAAO,kBAAkB,CAAC;gBACzC,QAAQ;YACV;SACD;IACH;IAEA,MAAM,WAA4B;QAChC,MAAM,MAAM,IAAI,CAAC,aAAa,CAAC;QAE/B,+CAA+C;QAC/C,IAAI,CAAC,KAAK;YACR,QAAQ,GAAG,CAAC;YACZ,OAAO,IAAI,CAAC,cAAc;QAC5B;QAEA,IAAI;YACF,MAAM,WAAW,MAAM,IAAI,CAAC,WAAW,CAAM,KAAK;gBAChD,QAAQ;YACV;YAEA,IAAI,QAAgB,EAAE;YAEtB,IAAI,MAAM,OAAO,CAAC,WAAW;gBAC3B,QAAQ;YACV,OAAO,IAAI,YAAY,OAAO,aAAa,UAAU;gBACnD,QAAQ,SAAS,KAAK,IAAI,SAAS,IAAI,IAAI,SAAS,KAAK,IAAI,SAAS,MAAM,IAAI,EAAE;gBAClF,IAAI,MAAM,MAAM,KAAK,GAAG;oBACtB,MAAM,SAAS,OAAO,MAAM,CAAC;oBAC7B,IAAI,OAAO,MAAM,GAAG,KAAK,MAAM,OAAO,CAAC,MAAM,CAAC,EAAE,GAAG;wBACjD,QAAQ,MAAM,CAAC,EAAE;oBACnB;gBACF;YACF;YAEA,MAAM,iBAAiB,MAAM,GAAG,CAAC,CAAC;gBAChC,IAAI,cAAwB,EAAE;gBAC9B,IAAI,OAAO,KAAK,WAAW,KAAK,UAAU;oBACxC,IAAI;wBACF,cAAc,KAAK,KAAK,CAAC,KAAK,WAAW;oBAC3C,EAAE,OAAO,GAAG;wBACV,cAAc,EAAE;oBAClB;gBACF,OAAO,IAAI,MAAM,OAAO,CAAC,KAAK,WAAW,GAAG;oBAC1C,cAAc,KAAK,WAAW;gBAChC;gBAEA,OAAO;oBACL,IAAI,KAAK,EAAE,IAAI,KAAK,GAAG,EAAE,QAAQ,KAAK,GAAG,IAAI,OAAO,KAAK,MAAM;oBAC/D,MAAM,KAAK,IAAI,IAAI,KAAK,QAAQ,IAAI;oBACpC,aAAa,KAAK,WAAW,IAAI,KAAK,IAAI,IAAI;oBAC9C,WAAW,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI;oBAC3C,aAAa;oBACb,WAAW,KAAK,SAAS,IAAI,KAAK,OAAO,IAAI,IAAI,OAAO,kBAAkB,CAAC;oBAC3E,QAAQ,KAAK,MAAM,KAAK,UAAU,KAAK,MAAM,KAAK;gBACpD;YACF;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,sCAAsC;YACpD,+DAA+D;YAC/D,OAAO,EAAE;QACX;IACF;IAEA,MAAM,WAAW,QAA2B,EAAiB;QAC3D,MAAM,MAAM,IAAI,CAAC,aAAa,CAAC;QAE/B,uDAAuD;QACvD,IAAI,CAAC,KAAK;YACR,QAAQ,GAAG,CAAC;YACZ,MAAM,QAAQ,OAAO,UAAU;YAC/B,MAAM,WAAiB;gBACrB,IAAI;gBACJ,MAAM,SAAS,IAAI;gBACnB,aAAa,SAAS,WAAW;gBACjC,WAAW;gBACX,aAAa,SAAS,WAAW;gBACjC,WAAW,IAAI,OAAO,kBAAkB,CAAC;gBACzC,QAAQ;YACV;YACA,OAAO;QACT;QAEA,IAAI;YACF,MAAM,WAAW,MAAM,IAAI,CAAC,YAAY,CAAC;gBACvC,gEAAgE;gBAChE,MAAM,QAAQ,OAAO,UAAU;gBAC/B,MAAM,UAAU;oBACd,IAAI;oBACJ,MAAM,SAAS,IAAI;oBACnB,aAAa,SAAS,WAAW;oBACjC,aAAa,KAAK,SAAS,CAAC,SAAS,WAAW;oBAChD,QAAQ;oBACR,WAAW;oBACX,WAAW,IAAI,OAAO,kBAAkB,CAAC;gBAC3C;gBAEA,QAAQ,GAAG,CAAC,+BAA+B;gBAE3C,OAAO,MAAM,IAAI,CAAC,WAAW,CAA+B,KAAK;oBAC/D,QAAQ;oBACR,MAAM,KAAK,SAAS,CAAC;gBACvB;YACF;YAEA,QAAQ,GAAG,CAAC,yBAAyB;YAErC,MAAM,cAAc,SAAS,IAAI,IAAI,SAAS,IAAI,IAAI;YACtD,IAAI,CAAC,aAAa;gBAChB,QAAQ,KAAK,CAAC,yCAAyC;gBACvD,MAAM,IAAI,MAAM;YAClB;YAEA,QAAQ,GAAG,CAAC,8BAA8B;YAC1C,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,mDAAmD;YACjE,wCAAwC;YACxC,MAAM,QAAQ,OAAO,UAAU;YAC/B,MAAM,WAAiB;gBACrB,IAAI;gBACJ,MAAM,SAAS,IAAI;gBACnB,aAAa,SAAS,WAAW;gBACjC,WAAW;gBACX,aAAa,SAAS,WAAW;gBACjC,WAAW,IAAI,OAAO,kBAAkB,CAAC;gBACzC,QAAQ;YACV;YACA,OAAO;QACT;IACF;IAEA,MAAM,WAAW,QAA2B,EAAiB;QAC3D,MAAM,MAAM,IAAI,CAAC,aAAa,CAAC;QAE/B,uDAAuD;QACvD,IAAI,CAAC,KAAK;YACR,QAAQ,GAAG,CAAC;YACZ,MAAM,WAAiB;gBACrB,IAAI,SAAS,EAAE;gBACf,MAAM,SAAS,IAAI;gBACnB,aAAa,SAAS,WAAW;gBACjC,WAAW;gBACX,aAAa,SAAS,WAAW;gBACjC,WAAW,IAAI,OAAO,kBAAkB,CAAC;gBACzC,QAAQ;YACV;YACA,OAAO;QACT;QAEA,IAAI;YACF,MAAM,WAAW,MAAM,IAAI,CAAC,YAAY,CAAC;gBACvC,gEAAgE;gBAChE,MAAM,UAAU;oBACd,IAAI,SAAS,EAAE;oBACf,MAAM,SAAS,IAAI;oBACnB,aAAa,SAAS,WAAW;oBACjC,aAAa,KAAK,SAAS,CAAC,SAAS,WAAW;oBAChD,QAAQ,OAAO,yBAAyB;gBAC1C;gBAEA,QAAQ,GAAG,CAAC,+BAA+B;gBAE3C,OAAO,MAAM,IAAI,CAAC,WAAW,CAA+B,KAAK;oBAC/D,QAAQ;oBACR,MAAM,KAAK,SAAS,CAAC;gBACvB;YACF;YAEA,QAAQ,GAAG,CAAC,yBAAyB;YAErC,MAAM,cAAc,SAAS,IAAI,IAAI,SAAS,IAAI,IAAI;YACtD,IAAI,CAAC,aAAa;gBAChB,QAAQ,KAAK,CAAC,yCAAyC;gBACvD,MAAM,IAAI,MAAM;YAClB;YAEA,QAAQ,GAAG,CAAC,8BAA8B;YAC1C,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,mDAAmD;YACjE,gDAAgD;YAChD,MAAM,WAAiB;gBACrB,IAAI,SAAS,EAAE;gBACf,MAAM,SAAS,IAAI;gBACnB,aAAa,SAAS,WAAW;gBACjC,WAAW;gBACX,aAAa,SAAS,WAAW;gBACjC,WAAW,IAAI,OAAO,kBAAkB,CAAC;gBACzC,QAAQ;YACV;YACA,OAAO;QACT;IACF;IAEA,MAAM,WAAW,MAAc,EAAiB;QAC9C,MAAM,MAAM,IAAI,CAAC,aAAa,CAAC;QAE/B,gEAAgE;QAChE,IAAI,CAAC,KAAK;YACR,QAAQ,GAAG,CAAC,0DAA0D;YACtE;QACF;QAEA,IAAI;YACF,MAAM,IAAI,CAAC,YAAY,CAAC;gBACtB,QAAQ,GAAG,CAAC,0BAA0B;gBAEtC,MAAM,WAAW,MAAM,IAAI,CAAC,WAAW,CAA0C,KAAK;oBACpF,QAAQ;oBACR,MAAM,KAAK,SAAS,CAAC;wBAAE,IAAI;oBAAO;gBACpC;gBAEA,QAAQ,GAAG,CAAC,yBAAyB;gBACrC,OAAO;YACT;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gEAAgE;YAC9E,2DAA2D;YAC3D;QACF;IACF;AACF;AAGO,MAAM,mBAAmB;IAC9B,QAAQ,GAAG,CAAC;IAEZ,MAAM,WAAW;QACf,GAAG;QACH,aAAa;QACb,MAAM;IACR;IAEA,QAAQ,GAAG,CAAC,4BAA4B;IAExC,oBAAoB;IACpB,IAAI,SAAS,GAAG,EAAE;QAChB,QAAQ,GAAG,CAAC;QACZ,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,SAAS,GAAG,EAAE;gBACzC,QAAQ;gBACR,SAAS;oBACP,gBAAgB;gBAClB;YACF;YAEA,QAAQ,GAAG,CAAC,wBAAwB,SAAS,MAAM;YACnD,QAAQ,GAAG,CAAC,yBAAyB,OAAO,WAAW,CAAC,SAAS,OAAO,CAAC,OAAO;YAEhF,IAAI,SAAS,EAAE,EAAE;gBACf,MAAM,OAAO,MAAM,SAAS,IAAI;gBAChC,QAAQ,GAAG,CAAC,sBAAsB;gBAClC,QAAQ,GAAG,CAAC,cAAc,OAAO;gBACjC,QAAQ,GAAG,CAAC,aAAa,MAAM,OAAO,CAAC;gBACvC,IAAI,QAAQ,OAAO,SAAS,UAAU;oBACpC,QAAQ,GAAG,CAAC,cAAc,OAAO,IAAI,CAAC;gBACxC;YACF,OAAO;gBACL,MAAM,YAAY,MAAM,SAAS,IAAI;gBACrC,QAAQ,KAAK,CAAC,uBAAuB;YACvC;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,uBAAuB;QACvC;IACF,OAAO;QACL,QAAQ,GAAG,CAAC;IACd;IAEA,wCAAwC;IACxC,IAAI,SAAS,aAAa,EAAE;QAC1B,QAAQ,GAAG,CAAC;QACZ,MAAM,cAAc;YAClB,MAAM;YACN,aAAa;YACb,aAAa,KAAK,SAAS,CAAC;gBAAC;aAAkB;YAC/C,QAAQ;YACR,WAAW;QACb;QAEA,QAAQ,GAAG,CAAC,iBAAiB;QAE7B,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,SAAS,aAAa,EAAE;gBACnD,QAAQ;gBACR,SAAS;oBACP,gBAAgB;gBAClB;gBACA,MAAM,KAAK,SAAS,CAAC;YACvB;YAEA,QAAQ,GAAG,CAAC,2BAA2B,SAAS,MAAM;YACtD,QAAQ,GAAG,CAAC,4BAA4B,OAAO,WAAW,CAAC,SAAS,OAAO,CAAC,OAAO;YAEnF,IAAI,SAAS,EAAE,EAAE;gBACf,MAAM,OAAO,MAAM,SAAS,IAAI;gBAChC,QAAQ,GAAG,CAAC,yBAAyB;YACvC,OAAO;gBACL,MAAM,YAAY,MAAM,SAAS,IAAI;gBACrC,QAAQ,KAAK,CAAC,0BAA0B;YAC1C;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,0BAA0B;QAC1C;IACF,OAAO;QACL,QAAQ,GAAG,CAAC;IACd;IAEA,QAAQ,GAAG,CAAC;AACd;AAGO,MAAM,kBAAkB;AAExB,MAAM,cAAc,IAAI","debugId":null}},
    {"offset": {"line": 1355, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/services/companyService.ts"],"sourcesContent":["import axios from 'axios';\r\nimport type { Company } from '@/lib/types';\r\n\r\nconst getCompanyWebhookUrl = () => {\r\n    const url = process.env.NEXT_PUBLIC_GET_COMPANY_WEBHOOK;\r\n    if (!url) {\r\n        console.warn('NEXT_PUBLIC_GET_COMPANY_WEBHOOK is not configured.');\r\n        return null;\r\n    }\r\n    return url;\r\n};\r\n\r\nconst getUpsertWebhookUrl = () => {\r\n    const url = process.env.NEXT_PUBLIC_UPSERT_WEBHOOK;\r\n    if (!url) {\r\n        console.warn('NEXT_PUBLIC_UPSERT_WEBHOOK is not configured.');\r\n        return null;\r\n    }\r\n    return url;\r\n};\r\n\r\nexport async function getAllCompanies(): Promise<Company[]> {\r\n    const webhookUrl = getCompanyWebhookUrl();\r\n    if (!webhookUrl) {\r\n        return [];\r\n    }\r\n\r\n    try {\r\n        const response = await axios.get(webhookUrl, { params: { id: 'all' } });\r\n        \r\n        if (response.status === 200 && Array.isArray(response.data)) {\r\n            return response.data.map(company => ({\r\n                ...company,\r\n                id: company.id || company._id?.$oid\r\n            }));\r\n        }\r\n        \r\n        // Handle cases where the API returns an object with a 'data' or other property\r\n        if (response.status === 200 && response.data && typeof response.data === 'object') {\r\n            const companyArray = response.data.data || response.data.companies || response.data.items || response.data.result;\r\n            if (Array.isArray(companyArray)) {\r\n                return companyArray.map(company => ({\r\n                    ...company,\r\n                    id: company.id || company._id?.$oid\r\n                }));\r\n            }\r\n        }\r\n        \r\n        console.warn(\"Webhook response for all companies was not in a recognized array format. Returning empty array.\", response.data);\r\n        return [];\r\n    } catch (error) {\r\n        console.error('Failed to get all companies from webhook:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function getCompanyById(companyId: string): Promise<Company | null> {\r\n    const webhookUrl = getCompanyWebhookUrl();\r\n    if (!webhookUrl) {\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        const response = await axios.get(webhookUrl, { params: { id: companyId } });\r\n        \r\n        if (response.status === 200 && response.data) {\r\n            const companyData = Array.isArray(response.data) ? response.data[0] : response.data;\r\n            if (companyData) {\r\n                return {\r\n                    ...companyData,\r\n                    id: companyData.id || companyData._id?.$oid\r\n                };\r\n            }\r\n        }\r\n        \r\n        console.warn(`No company found for companyId: ${companyId}`);\r\n        return null;\r\n    } catch (error) {\r\n        if (axios.isAxiosError(error)) {\r\n            if (error.response?.status === 404) {\r\n                console.warn(`Company not found (id: ${companyId})`);\r\n                return null;\r\n            } else {\r\n                console.error(`Failed to fetch company by ID ${companyId}:`, error.message);\r\n            }\r\n        } else {\r\n            console.error('An unexpected error occurred:', error);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function updateCompany(companyData: Partial<Company>): Promise<boolean> {\r\n    const webhookUrl = getUpsertWebhookUrl();\r\n    if (!webhookUrl) {\r\n        console.error('Cannot update company: NEXT_PUBLIC_UPSERT_WEBHOOK is not configured.');\r\n        return false;\r\n    }\r\n\r\n    try {\r\n        // Map frontend field names to match n8n flow expectations\r\n        const mappedData = {\r\n            active: true, // Always set to true for active companies\r\n            id: companyData.id,\r\n            company_name: companyData.company_name,\r\n            chat_bot_name: companyData.chat_bot_name,\r\n            user_count: companyData.user_count?.toString(), // Convert to string as expected by n8n\r\n            token_allotment: companyData.token_allotment?.toString(), // Convert to string as expected by n8n\r\n            max_workspace_sessions: [companyData.max_workspace_sessions], // Convert to array as expected by n8n flow\r\n            demo_environment: companyData.demo_environment ? 'true' : 'false', // Convert boolean to string\r\n            llm_config: companyData.llm_config,\r\n            openai_key: companyData[\"OpenAI API Key\"], // Map the OpenAI API Key field\r\n            url: companyData.url // ServiceNow Instance URL\r\n        };\r\n\r\n        console.log('Sending mapped company data to webhook:', mappedData);\r\n        \r\n        const response = await axios.post(webhookUrl, mappedData);\r\n        return response.status === 200 || response.status === 201;\r\n    } catch (error) {\r\n        console.error('Failed to update company via webhook:', error);\r\n        return false;\r\n    }\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1483, "column": 0}, "map": {"version":3,"sources":["file:///S:/Development/BabelPhish/code_base/ai_browser/src/app/dashboard/page.tsx"],"sourcesContent":["\r\n'use client';\r\n\r\nimport { useEffect, useState } from 'react';\r\nimport { useRouter } from 'next/navigation';\r\nimport { Dashboard } from \"@/components/Dashboard\";\r\nimport { SidebarProvider } from \"@/components/ui/sidebar\";\r\n\r\nexport default function DashboardPage() {\r\n  const router = useRouter();\r\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const session = localStorage.getItem('session');\r\n    if (!session) {\r\n      router.push('/');\r\n    } else {\r\n      setIsAuthenticated(true);\r\n    }\r\n  }, [router]);\r\n\r\n  if (!isAuthenticated) {\r\n    return null; // or a loading spinner\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <SidebarProvider defaultOpen={true}>\r\n        <Dashboard />\r\n      </SidebarProvider>\r\n    </div>\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;;AAGA;AACA;AACA;AACA;AALA;;;;;;AAOe,SAAS;IACtB,MAAM,SAAS,CAAA,GAAA,kIAAA,CAAA,YAAS,AAAD;IACvB,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAEvD,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,MAAM,UAAU,aAAa,OAAO,CAAC;QACrC,IAAI,CAAC,SAAS;YACZ,OAAO,IAAI,CAAC;QACd,OAAO;YACL,mBAAmB;QACrB;IACF,GAAG;QAAC;KAAO;IAEX,IAAI,CAAC,iBAAiB;QACpB,OAAO,MAAM,uBAAuB;IACtC;IAEA,qBACE,8OAAC;kBACC,cAAA,8OAAC,mIAAA,CAAA,kBAAe;YAAC,aAAa;sBAC5B,cAAA,8OAAC,+HAAA,CAAA,YAAS;;;;;;;;;;;;;;;AAIlB","debugId":null}}]
}